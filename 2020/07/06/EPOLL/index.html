<!DOCTYPE html><html lang="en"><head><title>Abracax</title><link rel="alternate" href="/atom.xml" type="application/atom.xml"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"><link href="https://fonts.googleapis.com/css?family=Playfair+Display" rel="stylesheet"><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"></script><script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"></script><meta charset="UTF-8"><link rel="icon" href="/blog/images/favicon.png"><link rel="stylesheet" href="/blog/css/style.css"><link rel="alternate" href="/blog/atom.xml" title="Abracax's Notes" type="application/atom+xml">
</head><body><div class="site-header"><div class="container"><div class="site-branding"><h1 class="site-title">Abracax's Notes<a href="google.com"></a></h1><div class="site-description"><span class="site-description-text"></span></div></div></div></div><div class="menu_box"><div class="menucon"><nav class="navbar navbar-expand-lg navbar-light bg-light"><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><div class="menucon"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="https://anxue.xyz/">About Me</a></li></ul></div><div class="menucon"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" target="_blank" rel="noopener" href="https://github.com/abracax">GitHub</a></li></ul></div></div></nav></div></div></body><div class="container"><div class="row"><div class="single-post"><article class="post-block"><h1 class="post-title">EPOLL</h1><header class="headgallery"></header><div class="row"><div class="tag-box"><div class="tags"></div></div></div><div class="post-content"><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p>We start with epoll_create. <code>epoll_create</code> can have an input flag EPOLL_CLOEXEC. O_CLOEXEC means close on <code>execve()</code>.</p>
<p>O_CLOEXEC avoids race conditions where one thread opens a file descriptor at the same time as another thread does a <code>fork() + execve()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create1, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> do_epoll_create(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So <code>epoll_create</code>tells us to look at <code>do_epoll_create</code>.</p>
<p>Must clarify some ambiguous abbreviated variable names before code:</p>
<ul>
<li>The fds epoll registers in the VFS are called <code>epfd</code></li>
<li><code>struct eventpoll</code> has variable name <code>ep</code></li>
<li><code>epi</code> has variable name of <code>epitem</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_epoll_create</span><span class="params">(<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> error, fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* Check the EPOLL_* constant for consistency.  */</span></span><br><span class="line">  BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Create the internal data structure (&quot;struct eventpoll&quot;).</span></span><br><span class="line"><span class="comment">   * ep_alloc uses kzalloc, slab cache quickens memory use.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  error = ep_alloc(&amp;ep);</span><br><span class="line">  <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Creates all the items needed to setup an eventpoll file. </span></span><br><span class="line"><span class="comment">   * Get an unused file descriptor and an anonymous inode file, use fd_install to bind them.</span></span><br><span class="line"><span class="comment">   * Set file operations: poll, release, llseek. </span></span><br><span class="line"><span class="comment">   * release closes file and llseek repositions the offset of the open file descriptor.</span></span><br><span class="line"><span class="comment">   * See eventpoll_fops below.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC)</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    error = fd;</span><br><span class="line">    <span class="keyword">goto</span> out_free_ep;</span><br><span class="line">  &#125;</span><br><span class="line">  file = anon_inode_getfile(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">         O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">    error = PTR_ERR(file);</span><br><span class="line">    <span class="keyword">goto</span> out_free_fd;</span><br><span class="line">  &#125;</span><br><span class="line">  ep-&gt;file = file;</span><br><span class="line">  fd_install(fd, file);</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">​</span><br><span class="line">out_free_fd:</span><br><span class="line">  put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">  ep_free(ep);</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AfterNotes:</p>
<p><code>ep_alloc</code> allocates slab cache.</p>
<p>Anonymous inode here is only available to the parent process, this is generally a good way to get a temporary file.</p>
<h2 id="File-Operations-of-Epoll"><a href="#File-Operations-of-Epoll" class="headerlink" title="File Operations of Epoll"></a>File Operations of Epoll</h2><p>The epoll instance is also pollable as a normal file. This allows us to monitor epoll instances with select, poll or even epoll itself!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">eventpoll_fops</span> =</span> &#123;</span><br><span class="line">  .show_fdinfo  = ep_show_fdinfo,</span><br><span class="line">  .release  = ep_eventpoll_release,</span><br><span class="line">  .poll   = ep_eventpoll_poll,</span><br><span class="line">  .llseek   = noop_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*release closes file and llseek repositions the offset of the open file descriptor.*/</span></span><br><span class="line"><span class="keyword">__poll_t</span> (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line"><span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line"><span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h2><p><code>struct event poll</code> is quite complicated.</p>
<p>The most important fields are:</p>
<ul>
<li>rbtree root</li>
<li>rdlist (ready list)</li>
<li>ovflist (overflow list)</li>
<li>epfd file pointer</li>
<li>wait queue of poll_wait epoll itself</li>
<li>wait queue of syscall epoll_wait, the wait queue in process scheduling.</li>
</ul>
<p>Epoll uses Red-Black Tree to listen on file descriptors. Keys are of type  <code>struct epoll_filefd</code>  , values of type <code>struct epitem</code>. Keys are compared by applying pointer arithmetic on file pointer address, and then comaring absoluted size of fds.</p>
<p><code>fdget</code> can also be used to implement key compare, but its a lot slower.</p>
<p><code>epi</code> are also in slab cache，since <code>ep_insert</code> calls <code>kmem_cache_alloc</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// file defined in &lt;linux/fs.h&gt;</span></span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></figure>

<p>ep_find is classic Red-Black Tree node search.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct epitem *<span class="title">ep_find</span><span class="params">(struct eventpoll *ep, struct file *file, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> kcmp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rbp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">epir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line">​</span><br><span class="line">  ep_set_ffd(&amp;ffd, file, fd);</span><br><span class="line">  <span class="keyword">for</span> (rbp = ep-&gt;rbr.rb_root.rb_node; rbp; ) &#123;</span><br><span class="line">    epi = rb_entry(rbp, struct epitem, rbn);</span><br><span class="line">    kcmp = ep_cmp_ffd(&amp;ffd, &amp;epi-&gt;ffd);</span><br><span class="line">    <span class="keyword">if</span> (kcmp &gt; <span class="number">0</span>)</span><br><span class="line">      rbp = rbp-&gt;rb_right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (kcmp &lt; <span class="number">0</span>)</span><br><span class="line">      rbp = rbp-&gt;rb_left;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      epir = epi;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> epir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each file descriptor added to the eventpoll interface will</span></span><br><span class="line"><span class="comment"> * have an entry of this type linked to the &quot;rbr&quot; RB tree.</span></span><br><span class="line"><span class="comment"> * Avoid increasing the size of this struct, there can be many thousands</span></span><br><span class="line"><span class="comment"> * of these on a server and we do not want this to take another cache line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RB tree node links this structure to the eventpoll RB tree</span></span><br><span class="line"><span class="comment">    * epitems are Values of the KV pair nodes in the RedblackTree</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">    <span class="comment">/* Used to free the struct epitem</span></span><br><span class="line"><span class="comment">    * RCU=Read-Copy Update Lock, lock for rbtree nodes</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* List header used to link this structure to the eventpoll ready list</span></span><br><span class="line"><span class="comment">  * &quot;struct eventpoll&quot;-&gt;rdlist</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">   * single linked chain of items. ovflist (overflow list) is used when we are</span></span><br><span class="line"><span class="comment">   * copying rdlist(ready list) from kernel space to user space</span></span><br><span class="line"><span class="comment">   * using epoll_wait.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* The file descriptor information this item refers to. </span></span><br><span class="line"><span class="comment">  * Rbtree key.</span></span><br><span class="line"><span class="comment">  * Contains file* and fd. See struct epoll_filefd definition above. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">  <span class="keyword">int</span> nwait;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* List containing poll wait queues.</span></span><br><span class="line"><span class="comment">  * This wait queue is the linux file system defined wait queue in &lt;linux/wait.h&gt;</span></span><br><span class="line"><span class="comment">  * Items in pwq list have type struct eppoll_entry.</span></span><br><span class="line"><span class="comment">  * It is a glue struct that links epitem to its wait_queue_entry and wait_queue_head</span></span><br><span class="line"><span class="comment">  *  (the head of the target file&#x27;s wait queue). Given a wait_queue_entry </span></span><br><span class="line"><span class="comment">  * we can calculate its epitem and eppoll_entry using pointer arithmetic.</span></span><br><span class="line"><span class="comment">  * However, normally a single epitem has only 1 epoll_entry linked to 1 wait queue </span></span><br><span class="line"><span class="comment">  * waiting on 1 file, it seems strange to have a linked list.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* The &quot;container&quot; of this item</span></span><br><span class="line"><span class="comment">  * The epoll instance, core of this piece of code.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list </span></span><br><span class="line"><span class="comment">  * Again, this normally contains only 1 item.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* wakeup_source used when EPOLLWAKEUP is set */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> __<span class="title">rcu</span> *<span class="title">ws</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* The structure that describe the interested events and the source fd</span></span><br><span class="line"><span class="comment">  *  One of the input structs in epoll system call.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Locks above are all RCU locks. Readers don’t need to get locks to read，since writers write on a copy and uses a callback function to change redirect pointer of old struct to the new copy. Lock-free preformance with many readers (except context-switch). CPU context switches are called quiescent state, readers need to wait for a signal that all CPUs have finished context switch (grace period). GC also occurs here.</p>
<h2 id="Callbacks-in-Epoll"><a href="#Callbacks-in-Epoll" class="headerlink" title="Callbacks in Epoll"></a>Callbacks in Epoll</h2><p><code>wait_queue_entry</code>s with callbacks packed inside are placed in wait queues of files being listened to, upon being available, they wake up all other threads in the wait queue and then links the <code>epitem</code> it is associated with to <code>epi-&gt;rdllink</code>, in the ready list of the epitem. Thus syscall epoll_wait needs only to retreive all ready fds from ready lists. Though it looks as if only ready list pointers are stored, but actually epitem pointers and ready list pointers can be transformed through pointer arithmetic.</p>
<p>wait_queue is deifined in <code>&lt;linux/wait.h&gt;</code>. <code>wait_queue_func_t</code> func is the callback function we want to look at, and epoll registers <code>ep_poll_callback</code> here。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</span><br><span class="line">  <span class="keyword">void</span>      *<span class="keyword">private</span>;</span><br><span class="line">  <span class="keyword">wait_queue_func_t</span> func;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">entry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* wait_queue_func_t  func is wake up function */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">wait_queue_func_t</span>)</span><span class="params">(struct wait_queue_entry *wq_entry, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>;</span><br></pre></td></tr></table></figure>

<p>There is a problem here that，<code>wait_queue_heads</code> for different files are placed in different places, thus we need a <code>eppoll_entry</code> glue struct to encapsulate wait queue structs and epitems.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> &#123;</span></span><br><span class="line">  <span class="comment">/* List header used to link this structure to the &quot;struct epitem&quot;, </span></span><br><span class="line"><span class="comment">  *  its struct list_head pwqlist.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span></span><br><span class="line">  <span class="comment">/* The &quot;base&quot; pointer is set to the container &quot;struct epitem&quot; */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">base</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait queue entry that will be linked to the target file wait</span></span><br><span class="line"><span class="comment">   * queue. It has a wake up function pointer in it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">wait_queue_entry_t</span> wait;</span><br><span class="line">  <span class="comment">/* The wait queue head that linked the &quot;wait&quot; wait queue item</span></span><br><span class="line"><span class="comment">  * It is stored at different places according to the particular </span></span><br><span class="line"><span class="comment">  * file implemenntation, take tcp as an example, it is sk_wq </span></span><br><span class="line"><span class="comment">  * stored inside the struct sock struct. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">wait_queue_head_t</span> *whead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>So how exactly do we place call_backs in the wait_queue in epoll?</p>
<p>We can see that <code>ep_insert</code> registers callbacks:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line">...</span><br><span class="line">epq.epi = epi;</span><br><span class="line">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"><span class="comment">/* ep_item_poll calls the corresponding file&#x27;s poll() implementation */</span></span><br><span class="line">revents = ep_item_poll(epi, &amp;epq.pt, <span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* glue struct to connect poll_table with epitem*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> &#123;</span></span><br><span class="line">  poll_table pt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">  poll_queue_proc _qproc;</span><br><span class="line">  <span class="keyword">__poll_t</span> _key;</span><br><span class="line">&#125; poll_table;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * structures and helpers for f_op-&gt;poll implementations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead, poll_table *pt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_poll</span><span class="params">(struct file *file, struct socket *sock, poll_table *wait)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>poll_queue_proc</code> is <code>poll</code> in file operation tables of different files, kernel code in<code>&lt;linux/poll.h&gt;</code>. For example, it is <code>tcp_poll();</code> for tcp sockets and <code>ep_ptable_queue_proc</code> for epoll.</p>
<p><code>ep_pqueue</code> is glue struct for connecting <code>poll_table</code> to <code>epitem</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is the callback that is used to add our wait queue to the</span></span><br><span class="line"><span class="comment">* target file wakeup lists.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead, poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* use pointer arithmetic from glue struct ep_pqueue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_epqueue(pt);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line"><span class="comment">/* init wait_queue_entry-&gt;wait_queue_func_t	func as ep_poll_callback</span></span><br><span class="line"><span class="comment">* add the wait_queue_entry to the files wait queue，Register ep_poll_callback() as wake 			  * queue wakeup function.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">    pwq-&gt;whead = whead;</span><br><span class="line">    pwq-&gt;base = epi;</span><br><span class="line">    add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">    list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line"><span class="comment">/* As stated above, nwait is normally 1 */</span></span><br><span class="line">    epi-&gt;nwait++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ep_poll_callback</code> actually enters wait queues of files. We have seen above that it places files into ready lists and wakes up other threads in the queue.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_entry_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* use glue struct eppoll_entry to get epitem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_wait(wait);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> epi-&gt;ep;</span><br><span class="line">    <span class="keyword">__poll_t</span> pollflags = key_to_poll(key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> ewake = <span class="number">0</span>;</span><br><span class="line">    read_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    ep_set_busy_poll_napi_id(epi);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the event mask does not contain any poll(2) event, we consider the</span></span><br><span class="line"><span class="comment">	 * descriptor to be disabled. This condition is likely the effect of the</span></span><br><span class="line"><span class="comment">	 * EPOLLONESHOT bit that disables the descriptor when an event is received,</span></span><br><span class="line"><span class="comment">	 * until the next EPOLL_CTL_MOD will be issued.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check the events coming with the callback. We had earlier set key_ to ~u0, </span></span><br><span class="line"><span class="comment">	 * to listen to all events, but at this stage, not</span></span><br><span class="line"><span class="comment">	 * every device reports the events in the &quot;key&quot; parameter of the</span></span><br><span class="line"><span class="comment">	 * callback. We need to be able to handle both cases here, hence the</span></span><br><span class="line"><span class="comment">	 * test for &quot;key&quot; != NULL before the event match test.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (pollflags &amp;&amp; !(pollflags &amp; epi-&gt;event.events))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are transferring events to userspace which makes rdlist unusable</span></span><br><span class="line"><span class="comment">	 * (via s y syscall epoll_wait()) we can hold no locks (because we read user space</span></span><br><span class="line"><span class="comment">   * memory, and because of linux f_op-&gt;poll() semantics). All the events that </span></span><br><span class="line"><span class="comment">	 * happen during that period of time are chained in ep-&gt;ovflist as overflow list </span></span><br><span class="line"><span class="comment">	 * and requeued to rdlist later on after transfer event has finished.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR &amp;&amp;</span><br><span class="line">            chain_epi_lockless(epi))</span><br><span class="line">            ep_pm_stay_awake_rcu(epi);</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If this file is already in the ready list we exit soon, this happens</span></span><br><span class="line"><span class="comment">	* when user does not call epoll_wait() for a long time. Else, we add it.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!ep_is_linked(epi) &amp;&amp;</span><br><span class="line">        list_add_tail_lockless(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        ep_pm_stay_awake_rcu(epi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wake up ( if active, which means not empty) both the eventpoll wait list and the -&gt;poll()</span></span><br><span class="line"><span class="comment">	 * wait list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((epi-&gt;event.events &amp; EPOLLEXCLUSIVE) &amp;&amp;</span><br><span class="line">                    !(pollflags &amp; POLLFREE)) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (pollflags &amp; EPOLLINOUT_BITS) &#123;</span><br><span class="line">            <span class="keyword">case</span> EPOLLIN:</span><br><span class="line">                <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLIN)</span><br><span class="line">                    ewake = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EPOLLOUT:</span><br><span class="line">                <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLOUT)</span><br><span class="line">                    ewake = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                ewake = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/* Wait queue used by syscall epoll_wait() */</span></span><br><span class="line">        wake_up(&amp;ep-&gt;wq);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* epoll Wait queue as a file, pwake keeps track of levels of reference */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line">out_unlock:</span><br><span class="line">    read_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE))</span><br><span class="line">        ewake = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pollflags &amp; POLLFREE) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we race with ep_remove_wait_queue() it can miss</span></span><br><span class="line"><span class="comment">		 * -&gt;whead = NULL and do another remove_wait_queue() after</span></span><br><span class="line"><span class="comment">		 * us, so we can&#x27;t use __remove_wait_queue().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        list_del_init(&amp;wait-&gt;entry);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * -&gt;whead != NULL protects us from the race with ep_free()</span></span><br><span class="line"><span class="comment">		 * or ep_remove(), ep_remove_wait_queue() takes whead-&gt;lock</span></span><br><span class="line"><span class="comment">		 * held by the caller. Once we nullify it, nothing protects</span></span><br><span class="line"><span class="comment">		 * ep/epi or even wait.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        smp_store_release(&amp;ep_pwq_from_wait(wait)-&gt;whead, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ewake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ep_item_poll</code>will poll the file using <code>vfs_poll</code>，i.e. <code>f_op-&gt;poll</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_item_poll</span><span class="params">(<span class="keyword">const</span> struct epitem *epi, poll_table *pt,</span></span></span><br><span class="line"><span class="function"><span class="params">				 <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> locked;</span><br><span class="line">    pt-&gt;_key = epi-&gt;event.events;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(epi-&gt;ffd.file))</span><br><span class="line">    <span class="comment">/* If it is not an epoll file, vfs_poll calls corresponding f_op-&gt;poll </span></span><br><span class="line"><span class="comment">    * of the file, tcp_poll for example.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">return</span> vfs_poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class="line">    ep = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">  <span class="comment">/* If the file is an epoll, do another level of poll_wait, call ep_ptable_queue_proc again*/</span></span><br><span class="line">    poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt);</span><br><span class="line">    locked = pt &amp;&amp; (pt-&gt;_qproc == ep_ptable_queue_proc);</span><br><span class="line">    <span class="keyword">return</span> ep_scan_ready_list(epi-&gt;ffd.file-&gt;private_data,</span><br><span class="line">                  ep_read_events_proc, &amp;depth, depth,</span><br><span class="line">                  locked) &amp; epi-&gt;event.events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">__poll_t</span> <span class="title">vfs_poll</span><span class="params">(struct file *file, struct poll_table_struct *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!file-&gt;f_op-&gt;poll))</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_POLLMASK;</span><br><span class="line">    <span class="keyword">return</span> file-&gt;f_op-&gt;poll(file, pt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ET-and-LT"><a href="#ET-and-LT" class="headerlink" title="ET and LT"></a>ET and LT</h2><p>ET(Edge Trigger) and LT(Level Trigger)<br>LT is default. It always puts all epitems back to ready lists, returns them back to user again and again at <code>epoll_wait</code>, thus it is repeatedly triggered. For ET, user only hears about them once in <code>epoll_wait</code>. ET assumes that user can handle event immediately after being notified. (Not a good assumption in most cases).</p>
<p>After copying data, if there are more epitems on the ready list, LT may wake up all <code>ep_&gt;wq</code> and <code>ep-&gt;poll_wait</code> processes. Some times this wake up process is too frequent.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wake up (if active) both the eventpoll wait list and</span></span><br><span class="line"><span class="comment">     * the -&gt;poll() wait list (delayed after we release the lock).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">      wake_up(&amp;ep-&gt;wq);</span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">      pwake++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</div></article><div class="paginator"><a class="prev" href="/blog/2020/11/15/CUDA/">prev</a><a class="next" href="/blog/2020/04/15/JobSearch/">next</a></div></div></div></div><div class="container-fluid"><div class="row"><div class="footer_box"><a class="col-lg-2 col-xl-2 col-md-2" href="/resume">Contact</a></div></div></div></html>