<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abracax&#39;s Notes</title>
  
  
  <link href="https://anxue.xyz/blog/atom.xml" rel="self"/>
  
  <link href="https://anxue.xyz/blog/"/>
  <updated>2021-08-29T15:22:04.869Z</updated>
  <id>https://anxue.xyz/blog/</id>
  
  <author>
    <name>Abracat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Networks Interview Prep</title>
    <link href="https://anxue.xyz/blog/2021/Networks-Interview-Prep/"/>
    <id>https://anxue.xyz/blog/2021/Networks-Interview-Prep/</id>
    <published>2021-08-29T15:21:33.000Z</published>
    <updated>2021-08-29T15:22:04.869Z</updated>
    
    <content type="html"><![CDATA[<p>Format of each TCP segment </p><ul><li>Sender-to-receiver information: <ul><li>Index of the first byte in the segment (sequence no.) </li><li>SYN bit: is this the beginning of the stream?</li><li>Contents of segment</li><li>FIN bit: is this the end of the stream? </li></ul></li><li>Receiver-to-sender information: <ul><li> Index of the next byte needed to assemble (ack no.) </li><li> No. of bytes beyond this willing to accept (window size)</li></ul></li></ul><h4 id="Packet-processing-by-an-Ethernet-Switch"><a href="#Packet-processing-by-an-Ethernet-Switch" class="headerlink" title="Packet processing by an Ethernet Switch"></a>Packet processing by an Ethernet Switch</h4><ol><li>Examine the header of each arriving frame. </li><li>If the Ethernet DA is in the forwarding table, forward the frame to the correct output port(s).</li><li>If the Ethernet DA is not in the table, broadcast the frame to all ports (except the one through which the frame arrived)</li><li>Entries in the table are learned by examining the Ethernet SA of arriving packets.</li></ol><h4 id="Lookup-Address-Ethernet"><a href="#Lookup-Address-Ethernet" class="headerlink" title="Lookup Address: Ethernet"></a>Lookup Address: Ethernet</h4><p>Ethernet MAC_DA = 0xA8B72340E678 Forward to port 7</p><p>DA all ones means Broadcast.</p><h4 id="Packet-processing-by-an-Internet-Router"><a href="#Packet-processing-by-an-Internet-Router" class="headerlink" title="Packet processing by an Internet Router"></a>Packet processing by an Internet Router</h4><ol><li>If the Ethernet DA of the arriving frame belongs to the router, accept the frame. Else drop it. </li><li>Examine the IP version number and length of the datagram. </li><li>Decrement the TTL, update the IP header checksum</li><li>Check to see if TTL == 0. </li><li>If the IP DA is in the forwarding table, forward to the correct egress port(s) for the next hop. </li><li>Find the Ethernet DA for the next hop router. </li><li>Create a new Ethernet frame and send it.</li></ol><h4 id="Lookup-Address-IPv4"><a href="#Lookup-Address-IPv4" class="headerlink" title="Lookup Address: IPv4"></a>Lookup Address: IPv4</h4><p>IP DA = 127.43.57.99 Forward to 56.99.32.16</p><p>Eth DA = Y AND IP DA = Z Drop packet</p><p><strong>Lookup is a longest prefix match, not an exact match!</strong></p><p><strong>Trie tree</strong></p><h2 id="Congestion-Control-amp-Flow-Control"><a href="#Congestion-Control-amp-Flow-Control" class="headerlink" title="Congestion Control &amp; Flow Control"></a>Congestion Control &amp; Flow Control</h2><p>Flow-control : sender respects receiver’s capacity</p><ul><li>receiver’s window (advertised from receiver), the spare room in the receive buffer </li><li>“congestion window” cwnd (maintained by sender) </li><li>The congestion window caps # of bytes in flight, same as receiver window. </li><li>When one more byte is acked (or judged lost), one more byte can be sent. This is called “self-clocking.”</li></ul><h3 id="Congestion-Control"><a href="#Congestion-Control" class="headerlink" title="Congestion Control"></a>Congestion Control</h3><p>TCP uses a mechanism called <a href="https://en.wikipedia.org/wiki/TCP_congestion_control#Slow_start">slow start</a>. It starts with a window, 1,4,2,10 (MSS) in size. Although the initial rate is low, the rate of increase is very rapid; for every packet acknowledged, the congestion window increases by 1 MSS so that the congestion window effectively doubles for every <a href="https://en.wikipedia.org/wiki/Round-trip_delay_time">round-trip time</a> (RTT).</p><p>When the congestion window exceeds the slow-start threshold, <em>ssthresh</em>, the algorithm enters a new state, called congestion avoidance. In congestion avoidance state, as long as non-duplicate ACKs are received the congestion window is additively increased by one MSS every round-trip time, <em>each new ACK</em> increases the CWND by <em>MSS / CWND.</em> This results in a linear increase of the CWND. This corresponds to the <a href="https://en.wikipedia.org/wiki/TCP_congestion_control#Additive_increase/multiplicative_decrease">AIMD algorithm described below</a>.</p><h4 id="TCP-Tahoe"><a href="#TCP-Tahoe" class="headerlink" title="TCP Tahoe"></a>TCP Tahoe</h4><p>When a loss occurs, <a href="https://en.wikipedia.org/wiki/TCP_congestion_control#Fast_retransmit">fast retransmit</a> is sent, half of the current CWND is saved as <em>ssthresh</em> and slow start begins again from its initial CWND. Once the CWND reaches <em>ssthresh</em>, TCP changes to congestion avoidance algorithm where <em>each new ACK</em> increases the CWND by <em>MSS / CWND.</em> This results in a linear increase of the CWND.</p><h4 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h4><p>A fast retransmit is sent, half of the current CWND is saved as <em>ssthresh</em> and as new CWND, thus skipping slow start and going directly to the congestion avoidance algorithm. The overall algorithm here is called fast recovery.</p><h4 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h4><p>The <strong>maximum segment size</strong> (<strong>MSS</strong>) is a parameter of the <em>options</em> field of the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a> header that specifies the largest amount of data, specified in <a href="https://en.wikipedia.org/wiki/Bytes">bytes</a>, that a computer or communications device can receive in a single <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">TCP segment</a>. It does not count the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">TCP header</a> or the <a href="https://en.wikipedia.org/wiki/IP_header">IP header</a>.</p><h3 id="Fast-retransmit"><a href="#Fast-retransmit" class="headerlink" title="Fast retransmit"></a>Fast retransmit</h3><p><strong>Fast retransmit</strong> is an enhancement to <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a> that reduces the time a sender waits before retransmitting a lost segment. If an acknowledgement is not received for a particular segment within a specified time (a function of the estimated <a href="https://en.wikipedia.org/wiki/Round-trip_delay_time">round-trip delay time</a>), the sender will assume the segment was lost in the network, and will retransmit the segment.</p><p>When a sender receives <strong>three duplicate</strong> acknowledgements, it can be reasonably confident that the segment carrying the data that followed the last in-order byte specified in the acknowledgment was lost. A sender with fast retransmit will then retransmit this packet immediately without waiting for its timeout. </p><h4 id="Duplicate-ack"><a href="#Duplicate-ack" class="headerlink" title="Duplicate ack"></a>Duplicate ack</h4><p>Duplicate acknowledgement is the basis for the fast retransmit mechanism. After receiving a packet an <strong>acknowledgement is sent for the last in-order byte of data received.</strong> For an in-order packet, this is effectively the <strong>last packet’s sequence number</strong> plus the current packet’s payload length. If the next packet in the sequence is lost but a third packet in the sequence is received, then the receiver can only acknowledge the last in-order byte of data, which is the same value as was acknowledged for the first packet. The second packet is lost and the third packet is not in order, so the last in-order byte of data remains the same as before. Thus a <em>Duplicate acknowledgement</em> occurs. The sender continues to send packets, and a fourth and fifth packet are received by the receiver. Again, the second packet is missing from the sequence, so the last in-order byte has not changed. Duplicate acknowledgements are sent for both of these packets.</p><h3 id="Sliding-window"><a href="#Sliding-window" class="headerlink" title="Sliding window"></a>Sliding window</h3><p>When the sender has to send some data, then it chooses the minimum of the size of the send buffer, congestion window and the receiver’s window and sends only that much data. The amount of data that can be sent represents the sliding window. Basically, the sliding window represents the amount of outstanding data that the sender has. If any of the windows (congestion or flow-control) opens up, then the window is stretched on the right.</p><h3 id="TCP-3-way-Handshake"><a href="#TCP-3-way-Handshake" class="headerlink" title="TCP 3-way Handshake"></a>TCP 3-way Handshake</h3><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/TCP-connection-1.png" alt="img"></p><p> <strong>Step 1 (SYN) :</strong> SYN(Synchronize Sequence Number)</p><p><strong>Step 2 (SYN + ACK):</strong> Server responds to the client request with SYN-ACK signal bits set. Acknowledgement(ACK) signifies the response of segment it received and SYN signifies with what sequence number it is likely to start the segments with</p><p><strong>Step 3 (ACK) :</strong> In the final part client acknowledges the response of server and they both establish a reliable connection with which they will start the actual data transfer</p><h2 id="TCP-Connection-Termination"><a href="#TCP-Connection-Termination" class="headerlink" title="TCP Connection Termination"></a>TCP Connection Termination</h2><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/CN.png" alt="11"></p><p><img src="http://www.serverframework.com/asynchronousevents/assets_c/2011/01/TCP-StateTransitionDiagram-NormalTransitions-thumb-500x749-271.png" alt="TCP-StateTransitionDiagram-NormalTransitions.png"></p><h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h3><p> Indicates that the receiver has received the first FIN signal from the initiator and the connection is in the process of being closed. This means the socket is waiting for the application to execute <code>close()</code>. A socket can be in CLOSE_WAIT state indefinitely until the application closes it. Faulty scenarios would be like a file descriptor leak: server not executing <code>close()</code> on sockets leading to pile up of CLOSE_WAIT sockets.</p><h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p><strong>TIME_WAIT</strong> indicates that local endpoint (this side) has closed the connection. <code>TIME_WAIT</code> is often also known as the 2MSL wait state. The MSL(<em>Maximum Segment Lifetime</em>) is the maximum amount of time that any segment, for all intents and purposes a datagram that forms part of the TCP protocol, can remain valid on the network before being discarded. Sometimes it can be 4 minutes, thus problematic. </p><ul><li>To prevent delayed segments from one connection being misinterpreted as being part of a subsequent connection. </li><li>The second reason for the <code>TIME_WAIT</code> state is to implement TCP’s full-duplex connection termination reliably. If the final <code>ACK</code> from initiator is dropped then the receiver will resend the final <code>FIN</code>. If the connection had transitioned to <code>CLOSED</code> on initiator then the only response possible would be to send an <code>RST</code> as the retransmitted <code>FIN</code> would be unexpected. This would cause end point 1 to receive an error even though all data was transmitted correctly.</li></ul><p><strong>How to avoid the 2MSL wait?</strong></p><ul><li>You can instead attempt to work around <code>TIME_WAIT</code> at the socket level with the <code>SO_REUSEADDR</code> socket option. This allows a socket to be created whilst an existing socket with the same address and port already exists. There’s another way to terminate a TCP connection and that’s by aborting the connection and sending an <code>RST</code> rather than a <code>FIN</code>. This is usually achieved by setting the <code>SO_LINGER</code> socket option to 0. </li></ul><h3 id="RST"><a href="#RST" class="headerlink" title="RST"></a>RST</h3><p><strong>Abrupt connection release :</strong><br>An abrupt connection release is carried out when a RST segment is sent.</p><ol><li>When a non-SYN segment was received for a non-existing TCP connection.</li><li>In an open connection, some TCP implementations send a RST segment when a segment with an invalid header is received. This will prevent attacks by closing the corresponding connection.</li><li>When some implementations need to close an existing TCP connection, they send a RST segment. They will close an existing TCP connection for the following reasons:<ul><li>Lack of resources to support the connection</li><li>The remote host is now unreachable and has stopped responding.</li></ul></li></ol><h2 id="Epoll-and-Select-Poll"><a href="#Epoll-and-Select-Poll" class="headerlink" title="Epoll and Select/Poll"></a>Epoll and Select/Poll</h2><p>A typical server might be dealing with, say, 200 connections.</p><p>For epoll, each connection on the server would register themselves on the <code>epoll</code> socket wait queue. So 1 wait queue busy. </p><p>However, in select each connection will be registered in a different wait queue, depending on the resource they require. So 200 wait queues busy. </p><p><strong>Ironically, with <code>select</code>, the largest cost comes from checking if sockets that have had no activity have had any activity.</strong> With <code>epoll</code>, there is no need to check sockets that have had no activity because if they did have activity, they would have informed the <code>epoll</code> socket when that activity happened.</p><p>Another main difference between <code>epoll</code> and <code>select</code> is that in <code>select()</code> the list of file descriptors to wait on only exists for the duration of a single <code>select()</code> call, and the calling task only stays on the sockets’ wait queues for the duration of a single call.</p><h5 id="Poll-and-Select-differ-in-FD-amount"><a href="#Poll-and-Select-differ-in-FD-amount" class="headerlink" title="Poll and Select differ in FD amount"></a>Poll and Select differ in FD amount</h5><h3 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h3><p>Gnet, Node.js, libuev, libevent</p><p>And many other light weight event loop libraries.</p><h3 id="RedBlack-Tree"><a href="#RedBlack-Tree" class="headerlink" title="RedBlack Tree"></a>RedBlack Tree</h3><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20200427100650/red-black-tree.png" alt="img"></p><h4 id="Rules-That-Every-Red-Black-Tree-Follows"><a href="#Rules-That-Every-Red-Black-Tree-Follows" class="headerlink" title="Rules That Every Red-Black Tree Follows:"></a><strong>Rules That Every Red-Black Tree Follows:</strong></h4><ol><li>Every node has a colour either red or black.</li><li>The root of the tree is always black.</li><li>There are no two adjacent red nodes (A red node cannot have a red parent or red child).</li><li>Every path from a node (including root) to any of its descendants NULL nodes has the same number of black nodes.</li></ol><h2 id="OSI-7-layers"><a href="#OSI-7-layers" class="headerlink" title="OSI 7 layers"></a>OSI 7 layers</h2><p><img src="https://www.imperva.com/learn/wp-content/uploads/sites/13/2020/02/OSI-7-layers.jpg.webp" alt="OSI 7 layers"></p><p>OSI: Open Systems Interconnection</p><p>TCP/IP are used a lot more than OSI/RM now, it combines the upper 3 layers. </p><h2 id="Skicky-Packets"><a href="#Skicky-Packets" class="headerlink" title="Skicky Packets"></a>Skicky Packets</h2><ul><li><p>Sending : TCP protocol uses the Nagle algorithm by default to merge the connected small packets and send them one at a time to improve the efficiency of network transmission. </p><ul><li><code>setsockopt(m_socket, IPPROTO_TCP, TCP_NODELAY, &amp;chOpt, sizeof(char));</code> to disable.</li></ul></li><li><p>Receiving: The speed at which the network transmits data may be faster than the speed at which the receiver processes the data, causing the receiver to have multiple packets in the buffer when it reads the buffer. In the TCP protocol, the receiver is reading all the contents of the buffer at once, so it cannot reflect the original data information.</p></li></ul><p>A simple solution is to add a header to each TCP packet at the sender.</p><h2 id="HTTP-state"><a href="#HTTP-state" class="headerlink" title="HTTP state"></a>HTTP state</h2><p>Add tokens to HTTP requests to protect against CSRF attacks.</p><table><thead><tr><th>1**</th><th>信息，服务器收到请求，需要请求者继续执行操作</th></tr></thead><tbody><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><strong>HTTPS</strong> 在内容传输的<strong>加密</strong>上<strong>使用</strong>的是<strong>对称加密</strong>，非<strong>对称加密</strong>只作用在证书验证阶段.</p><p>HTTPS is as a wrapper on top of TLS using SSL certificate.</p><p><img src="https://images.ctfassets.net/slt3lc6tev37/5aYOr5erfyNBq20X5djTco/3c859532c91f25d961b2884bf521c1eb/tls-ssl-handshake.png" alt="What happens in a TLS handshake? | SSL handshake | Cloudflare"></p><p><img src="https://perezbox.com/wp-content/uploads/2018/10/Screen-Shot-2018-10-28-at-9.57.00-AM-1140x832.png" alt="img"></p><h2 id="Websocket-and-HTTP"><a href="#Websocket-and-HTTP" class="headerlink" title="Websocket and HTTP"></a>Websocket and HTTP</h2><p>Both based on tcp and application level.</p><p>Websocket is a 2-way protocol.</p><h3 id="HTTP-GET-and-POST"><a href="#HTTP-GET-and-POST" class="headerlink" title="HTTP GET and POST"></a>HTTP GET and POST</h3><ul><li>For GET parameters are all encoded in URL, thus only ASCII. POST is in request body.</li><li>GET parameters are cached in browser history, doesn’t harm to repeat request a GET.</li></ul><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ol><li><p>Browser Cache</p></li><li><p>Local hosts file</p></li><li><p>local DNS server cache</p></li><li><p>DNS server</p></li><li><p>Recursive request DNS</p><p>当<strong>DNS</strong>查询超过512字节时，<strong>协议</strong>的TC标志出现删除标志，这时则<strong>使用TCP</strong>发送。</p></li></ol><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>IP Adress = {<code>net_id</code>, <code>host_id</code>}</p><h2 id="IPV4-and-IPV6"><a href="#IPV4-and-IPV6" class="headerlink" title="IPV4 and IPV6"></a>IPV4 and IPV6</h2><ul><li>IPv4 is 32-Bit IP address whereas IPv6 is a 128-Bit IP address.</li><li>IPv4 is a numeric addressing method whereas IPv6 is an alphanumeric addressing method.</li><li>IPv4 offers 12 header fields whereas IPv6 offers 8 header fields.</li><li><strong>IPv4 supports broadcast whereas IPv6 doesn’t support broadcast.</strong></li><li>IPv4 has checksum fields while <strong>IPv6 doesn’t have checksum fields</strong></li><li>When we compare IPv4 and IPv6, IPv4 supports VLSM (<strong>Variable Length Subnet Mask</strong>) whereas IPv6 doesn’t support VLSM.</li><li><strong>IPv4 uses ARP (Address Resolution Protocol) to map to MAC address whereas IPv6 uses NDP (Neighbour Discovery Protocol) to map to MAC address.</strong></li></ul><h3 id="Subnet-Mask"><a href="#Subnet-Mask" class="headerlink" title="Subnet Mask"></a>Subnet Mask</h3><h2 id="HTTP3-0-HTTP-over-QUIC"><a href="#HTTP3-0-HTTP-over-QUIC" class="headerlink" title="HTTP3.0 (HTTP-over-QUIC)"></a><strong>HTTP3.0</strong> (HTTP-over-QUIC)</h2><p><strong>HTTP/2-encrypted-over-UDP</strong></p><p>0-RTT handshake.</p><p><a href="https://www.jianshu.com/p/52d86558ca57">https://www.jianshu.com/p/52d86558ca57</a></p><h2 id="Forward-and-Redirect"><a href="#Forward-and-Redirect" class="headerlink" title="Forward and Redirect"></a>Forward and Redirect</h2><p><img src="/blog/Users/chenanxue/Work/Industry/notes/2639681048-5e51e65aac2b2_articlex.png" alt="img"></p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Format of each TCP segment &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sender-to-receiver information: &lt;ul&gt;
&lt;li&gt;Index of the first byte in the segment (sequence no.) &lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DataBase Systems Interview Prep</title>
    <link href="https://anxue.xyz/blog/2021/DB-Interview-Prep/"/>
    <id>https://anxue.xyz/blog/2021/DB-Interview-Prep/</id>
    <published>2021-08-29T15:17:54.000Z</published>
    <updated>2021-08-29T15:20:10.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Clustered-index-and-non-clustered-index"><a href="#Clustered-index-and-non-clustered-index" class="headerlink" title="Clustered index and non-clustered index"></a>Clustered index and non-clustered index</h2><ul><li><p>A clustered index defines the order in which data is physically stored in a table. In SQL Server, the primary key constraint automatically creates a clustered index on that particular column.</p></li><li><p>A non-clustered index doesn’t sort the physical data inside the table. In fact, a non-clustered index is stored at one place and table data is stored in another place.</p></li></ul><h2 id="Why-B-Tree"><a href="#Why-B-Tree" class="headerlink" title="Why B+ Tree"></a>Why B+ Tree</h2><ul><li>Because B+ trees don’t have data associated with interior nodes, more keys can fit on a page of memory. Disk IO is slow and disk read blocks into buffers. B+tree places storage together, it will require fewer cache misses in order to access data that is on a leaf node.</li><li>The leaf nodes of B+ trees are linked, so doing a full scan of all objects in a tree requires just one linear pass through all the leaf nodes. </li></ul><h2 id="MyISAM-and-InnoDB"><a href="#MyISAM-and-InnoDB" class="headerlink" title="MyISAM and InnoDB"></a>MyISAM and InnoDB</h2><p>So to summarize (<em>TL;DR</em>):</p><ul><li>InnoDB has row-level locking, MyISAM can only do full table-level locking, does not have transactions.</li><li>MyISAM has better performance in <code>select</code> InnoDB is better at <strong>INSERT</strong> or <strong>UPDATE</strong>.</li><li>InnoDB does not support <code>FULLTEXT</code>.</li><li>InnoDB has foreign key.</li><li>InnoDB implements transactions, foreign keys and relationship constraints, MyISAM does not.</li><li>MyISAM uses non-clustered indexes, seperating index pages and data pages.</li></ul><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><strong>InnoDB</strong></h2><ul><li>InnoDB uses LRU (Least Recently Used ) page replacement algorithm.</li><li>Data that is being reused is always in the same memory.</li></ul><p><img src="https://lalitvc.files.wordpress.com/2016/11/innodb_arch1.png?w=776" alt="innodb_arch"></p><p>The pages in the buffer pool are B+ tree nodes of size 16KB, each nodes contain at least 2 rows, thus max row rize is <strong>8098</strong>.</p><p>Each page contains:</p><blockquote><p>File Header</p><p>Page Header</p><p>Infimun + Supremum Records</p><p>User Records</p><p>Free Space</p><p>Page Directory</p><p>File Trailer</p></blockquote><ul><li><p>Infimum is values smaller than any primary key in the page，Supremum is larger then any primary key.</p></li><li><p>Perform binary search on <code>Page Directory</code> which maps records to slots. Each slot has 4-8 records. </p></li></ul><h3 id="How-to-Search"><a href="#How-to-Search" class="headerlink" title="How to Search?"></a>How to Search?</h3><p>Use B+ tree to find page, fetch it from disk to buffer pool, Perform binary search on <code>Page Directory</code> , then search in linked list.</p><h3 id="Clustered-index-and-Secondary-index-in-InnoDB"><a href="#Clustered-index-and-Secondary-index-in-InnoDB" class="headerlink" title="Clustered index and Secondary index in InnoDB"></a>Clustered index and Secondary index in InnoDB</h3><ul><li>Clustered index in InnoDB is the B+ tree primary keys in the table form, alll other data are in pages. These pages are both index pages and data pages. Each table only has 1 clustered index.</li><li>Non-clustered index:  Primary keys form b+trees with pointers to pages where data is stored. The second key index column is a non-clustered index.</li></ul><h3 id="Searching-Twice-回表查询"><a href="#Searching-Twice-回表查询" class="headerlink" title="Searching Twice 回表查询"></a>Searching Twice <strong>回表查询</strong></h3><p><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729184911699-676257427.png" alt="img"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'list'</span><span class="token punctuation">;</span>　<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="索引覆盖-Covering-index"><a href="#索引覆盖-Covering-index" class="headerlink" title="索引覆盖(Covering index)"></a><strong>索引覆盖</strong>(Covering index)</h2><p>被查询的字段建立到联合索引里去, 无需回表查询。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span>name <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'list'</span><span class="token punctuation">;</span>　<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Combined-index-联合索引与最左原则"><a href="#Combined-index-联合索引与最左原则" class="headerlink" title="Combined index 联合索引与最左原则"></a>Combined index 联合索引与最左原则</h2><p>对于复合索引：Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</p><p>例如索引是 key index （a,b,c）。 可以支持 <code>a</code> 、<code>a,b</code> 、<code>a,b,c</code> 3种组合进行查找，但不支持 b,c 进行查找。</p><p><img src="http://www.2cto.com/uploadfile/Collfiles/20180217/20180217145611186.png" alt="多列索引数据结构"></p><h2 id="ACID-atomicity-consistency-isolation-durability"><a href="#ACID-atomicity-consistency-isolation-durability" class="headerlink" title="ACID (atomicity, consistency, isolation, durability)"></a><em>ACID</em> (atomicity, consistency, isolation, durability)</h2><h3 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h3><p>Atomicity means that you guarantee that either all of the transaction succeeds or none of it does. You don’t get part of it succeeding and part of it not. </p><h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>This ensures that you guarantee that all data will be consistent. </p><h3 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h3><p>Guarantees that all transactions will occur in isolation. No transaction will be affected by any other transaction.</p><h3 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h3><p>Durability means that, once a transaction is committed, it will remain in the system – even if there’s a system crash immediately following the transaction. Any changes from the transaction must be stored permanently. </p><h2 id="Transaction-Isolation-Levels"><a href="#Transaction-Isolation-Levels" class="headerlink" title="Transaction Isolation Levels"></a>Transaction Isolation Levels</h2><ol><li><strong>Read Uncommitted –</strong> Read Uncommitted is the lowest isolation level. In this level, one transaction may read not yet committed changes made by other transaction, thereby allowing dirty reads. In this level, transactions are not isolated from each other.</li><li><strong>Read Committed –</strong> This isolation level guarantees that any data read is committed at the moment it is read. Thus it does not allows dirty read. The transaction holds a read or write lock on the current row, and thus prevent other transactions from reading, updating or deleting it.</li><li><strong>Repeatable Read –</strong> This is the most restrictive isolation level. The transaction holds read locks on all rows it references and writes locks on all rows it inserts, updates, or deletes. Since other transaction cannot read, update or delete these rows, consequently it avoids non-repeatable read.</li><li><strong>Serializable –</strong> This is the Highest isolation level. A <em>serializable</em> execution is guaranteed to be serializable. Serializable execution is defined to be an execution of operations in which concurrently executing transactions appears to be serially executing.</li></ol><h4 id="A-transaction-isolation-level-is-defined-by-the-following-phenomena"><a href="#A-transaction-isolation-level-is-defined-by-the-following-phenomena" class="headerlink" title="A transaction isolation level is defined by the following phenomena:"></a>A transaction isolation level is defined by the following phenomena:</h4><ul><li><strong>Dirty Read (mvcc)–</strong> A Dirty read is the situation when a transaction reads a data that has not yet been committed. <ul><li>For example, Let’s say transaction 1 updates a row and leaves it uncommitted, meanwhile, Transaction 2 reads the updated row. If transaction 1 rolls back the change, transaction 2 will have read data that is considered never to have existed.</li></ul></li><li><strong>Non Repeatable read (mvcc) –</strong> Non Repeatable read occurs when a transaction reads same row twice, and get a different value each time. <ul><li>For example, suppose transaction T1 reads data. Due to concurrency, another transaction T2 updates the same data and commit, Now if transaction T1 rereads the same data, it will retrieve a different value.</li></ul></li><li><strong>Phantom Read(next-key lock) –</strong> Phantom Read occurs when two same queries are executed, all the rows in the query have the same value before and after, but the rows retrieved by the two, are different. <ul><li>For example, suppose transaction T1 retrieves a set of rows that satisfy some search criteria. Now, Transaction T2 generates some new rows that match the search criteria for transaction T1. If transaction T1 re-executes the statement that reads the rows, it gets a different set of rows this time.</li></ul></li></ul><h2 id="1NF-2NF-3NF-and-BCNF"><a href="#1NF-2NF-3NF-and-BCNF" class="headerlink" title="1NF, 2NF, 3NF and BCNF"></a>1NF, 2NF, 3NF and BCNF</h2><h5 id="Normal-Forms"><a href="#Normal-Forms" class="headerlink" title="Normal Forms"></a>Normal Forms</h5><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>Each attribute of a table must have atomic (single) values</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>No non-prime attribute is dependent on the proper subset of any candidate key of <strong>table</strong></p><p>e.g. Age depends on ID.</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p><a href="https://beginnersbook.com/2015/04/transitive-dependency-in-dbms/">Transitive functional dependency</a> of non-prime attribute on any super key should be removed.</p><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p><strong>Example</strong>: Suppose there is a company wherein employees work in <strong>more than one department</strong>. They store the data like this:</p><table><thead><tr><th>emp_id</th><th>emp_nationality</th><th>emp_dept</th><th>dept_type</th><th>dept_no_of_emp</th></tr></thead><tbody><tr><td>1001</td><td>Austrian</td><td>Production and planning</td><td>D001</td><td>200</td></tr><tr><td>1001</td><td>Austrian</td><td>stores</td><td>D001</td><td>250</td></tr><tr><td>1002</td><td>American</td><td>design and technical support</td><td>D134</td><td>100</td></tr><tr><td>1002</td><td>American</td><td>Purchasing department</td><td>D134</td><td>600</td></tr></tbody></table><p><strong>Functional dependencies in the table above</strong>:<br>emp_id -&gt; emp_nationality<br>emp_dept -&gt; {dept_type, dept_no_of_emp}</p><p><strong>Candidate key</strong>: {emp_id, emp_dept}</p><p>The table is not in BCNF as neither emp_id nor emp_dept alone are keys.</p><h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><p><img src="https://www.codeproject.com/KB/database/Visual_SQL_Joins/Visual_SQL_JOINS_V2.png" alt="Image 8"></p><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><p>PreparedStatement compiles the SQL Statement in the first run itself. Thus, if the Statement is preparedStatement, you can run the Statement multiple times without having to compile it again and again. </p><p>It can protect system against sql injection.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'administrator'</span><span class="token comment">--' AND password = '';</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> user_table <span class="token keyword">WHERE</span> username<span class="token operator">=</span><span class="token string">'’or 1 = 1 -- and password='</span>’<span class="token keyword">UNION</span> <span class="token keyword">SELECT</span> username<span class="token punctuation">,</span> password <span class="token keyword">FROM</span> users<span class="token comment">--;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> products <span class="token keyword">WHERE</span> category <span class="token operator">=</span> <span class="token string">'"+ input + "'</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span><span class="token keyword">tables</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MVCC-Multi-Version-Concurrency-Control"><a href="#MVCC-Multi-Version-Concurrency-Control" class="headerlink" title="MVCC(Multi-Version Concurrency Control)"></a>MVCC(Multi-Version Concurrency Control)</h2><p> Optimistic locking mechanism.</p><p>MVCC uses <a href="https://en.wikipedia.org/wiki/Timestamp">timestamps</a> (<strong>TS</strong>), and <em>incrementing transaction IDs</em>, to achieve <em>transactional consistency</em>. MVCC ensures a transaction (<strong>T</strong>) never has to wait to <em>Read</em> a database object (<strong>P</strong>) by maintaining several versions of the object. Each version of object <strong>P</strong> has both a <em>Read Timestamp</em> (<strong>RTS</strong>) and a <em>Write Timestamp</em> (<strong>WTS</strong>) which lets a particular transaction <strong>Ti</strong> read the most recent version of the object which precedes the transaction’s <em>Read Timestamp</em> <strong>RTS</strong>(<strong>Ti</strong>).</p><p>The drawback to this system is the cost of storing multiple versions of objects in the database. On the other hand, reads are never blocked, which can be important for workloads mostly involving reading values from the database. MVCC is particularly adept at implementing true <a href="https://en.wikipedia.org/wiki/Snapshot_isolation">snapshot isolation</a>, something which other methods of concurrency control frequently do either incompletely or with high performance costs.</p><h3 id="Next-key-lock"><a href="#Next-key-lock" class="headerlink" title="Next-key lock"></a>Next-key lock</h3><p>A next-key lock is <strong>a combination of a record lock on the index record and a gap lock on the gap before the index record</strong>.</p><p>A gap lock is <strong>a lock on the gap between index records</strong>. Thanks to this gap lock, when you run the same query twice, you get the same result, regardless other session modifications on that table. This makes reads consistent and therefore makes the replication between servers consistent.</p><h2 id="Redo-log-undo-log-and-binlog"><a href="#Redo-log-undo-log-and-binlog" class="headerlink" title="Redo log, undo log and binlog"></a>Redo log, undo log and binlog</h2><h3 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h3><h5 id="WAL"><a href="#WAL" class="headerlink" title="WAL."></a>WAL.</h5><p>Write redolog before modifying the page. Redo it if transaction fails. </p><h4 id="Flushing"><a href="#Flushing" class="headerlink" title="Flushing"></a>Flushing</h4><ul><li>Master Thread Refresh redo log buffer to redo log file every second</li><li>The redo log buffer is flushed to the redo log file when each transaction is committed</li><li>When the remaining space of redo log buffer pool is less than 1/2 when , Redo log is refreshed to redo log file</li></ul><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>Provides rollback and multiple row versioning (MVCC).</p><ul><li>MVCC： When the user reads a row of records , If the record is already occupied by another transaction , The current transaction can be processed through undo Read previous line version information , In order to achieve non lock read .</li></ul><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>The binary log contains “events” that describe database changes such as table creation operations or changes to table data. The binary log also contains information about how long each statement took that updated data. </p><ol><li>For replication, the binary log on a primary replication server provides a record of the data changes to be sent to secondary servers. The primary server sends the events contained in its binary log to its secondaries, which execute those events to make the same data changes that were made on the primary.</li><li>Certain data recovery operations require the use of the binary log. After a backup has been restored, the events in the binary log that were recorded after the backup was made are re-executed. These events bring databases up to date from the point of the backup</li></ol><h2 id="Distributed-Transactions"><a href="#Distributed-Transactions" class="headerlink" title="Distributed Transactions"></a>Distributed Transactions</h2><p><a href="https://pdos.csail.mit.edu/6.824/notes/l-2pc.txt">https://pdos.csail.mit.edu/6.824/notes/l-2pc.txt</a></p><h2 id="Two-phase-commit-voting"><a href="#Two-phase-commit-voting" class="headerlink" title="Two-phase commit (voting)"></a>Two-phase commit (voting)</h2><h4 id="Prepare-phase"><a href="#Prepare-phase" class="headerlink" title="Prepare phase"></a>Prepare phase</h4><ol><li>After each database store (slave) has locally completed its transaction, it sends a “<em>DONE</em>” message to the transaction coordinator. Once the coordinator receives this message from <em>all</em> the slaves, it sends them a “<em>PREPARE</em>” message.</li><li>Each slave responds to the “<em>PREPARE</em>” message by sending a “<em>READY</em>” message back to the coordinator</li><li>If a slave responds with a “<em>NOT READY</em>” message or does not respond at all, then the coordinator sends a global “<em>ABORT</em>” message to all the other slaves. Only upon receiving an acknowledgment from <em>all</em> the slaves that the transaction has been aborted does the coordinator consider the entire transaction aborted.</li></ol><h4 id="Commit-phase"><a href="#Commit-phase" class="headerlink" title="Commit phase"></a>Commit phase</h4><ol><li>Once the transaction coordinator has received the “<em>READY</em>” message from <em>all</em> the slaves, it sends a “<em>COMMIT</em>” message to all of them, which contains the details of the transaction that needs to be stored in the databases.</li><li>…. Same as before</li></ol><h2 id="NVM"><a href="#NVM" class="headerlink" title="NVM"></a>NVM</h2><p><a href="https://nan01ab.github.io/2019/02/NVMM-of-DB.html">https://nan01ab.github.io/2019/02/NVMM-of-DB.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Clustered-index-and-non-clustered-index&quot;&gt;&lt;a href=&quot;#Clustered-index-and-non-clustered-index&quot; class=&quot;headerlink&quot; title=&quot;Clustered inde</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Operating Systems Interview Prep</title>
    <link href="https://anxue.xyz/blog/2021/OSInterviewPrep/"/>
    <id>https://anxue.xyz/blog/2021/OSInterviewPrep/</id>
    <published>2021-08-12T12:19:27.000Z</published>
    <updated>2021-08-29T15:17:12.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h2><ul><li><p>Cost of scheduling: Context switch. Cost of synchronization and communication. </p></li><li><p>Parallelization: Parallelization in a single process. Support for multiple machines.</p></li><li><p>Resources: Processes are much more expensive. Threads share resources at low cost in a single process, share code segment, data segment, open files and other system resources. Same heap, independant stacks. Processes have independent address space and resources. </p></li></ul><h2 id="Syscalls"><a href="#Syscalls" class="headerlink" title="Syscalls"></a>Syscalls</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># save all registers# pushfl, pushal# store ss0, esp0, cs, eip, eflags, ss, esp# The three privilege-level stack pairs (SS0:ESP0, SS1:ESP1, SS2:ESP2)# task state segment (TSS)int 0x80; # vector in IDTcall syscall_func_c_land;iret;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>In int 0x80, all registers below will be pushed onto stack.</p><p>The <code>USER_CS</code> and <code>USER_DS</code> information are from the TSS(task state segment).</p><p>A segment register called the task register (TR) holds a <a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">segment selector</a> that points to a valid TSS segment descriptor which resides in the GDT. The TSS may reside anywhere in <a href="https://en.wikipedia.org/wiki/Memory">memory</a>.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* the order to push are as follows:       0 | ss (USER_DS)       esp  (132MB USER_STACK_BASE)       eflags (pushfl)       0 | cs (USER_CS)       eip*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><h3 id="Shared-files-fcntl-filelocks"><a href="#Shared-files-fcntl-filelocks" class="headerlink" title="Shared files,  fcntl, filelocks"></a>Shared files,  <strong>fcntl</strong>, filelocks</h3><h3 id="Shared-memory-with-semaphores-fastest"><a href="#Shared-memory-with-semaphores-fastest" class="headerlink" title="Shared memory (with semaphores, fastest)"></a>Shared memory (with semaphores, fastest)</h3><ul><li>std::mutex does not support interprocess operation but pthread library has interprocess mutex</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">caddr_t</span> memptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>       <span class="token comment">/* let system pick where to put segment */</span>                        ByteSize<span class="token punctuation">,</span>   <span class="token comment">/* how many bytes */</span>                        PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> <span class="token comment">/* access protections */</span>                        MAP_SHARED<span class="token punctuation">,</span> <span class="token comment">/* mapping visible to other processes */</span>                        fd<span class="token punctuation">,</span>         <span class="token comment">/* file descriptor */</span>                        <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">/* offset: start at 1st byte */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">caddr_t</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token operator">==</span> memptr<span class="token punctuation">)</span> <span class="token function">report_and_exit</span><span class="token punctuation">(</span><span class="token string">"Can't get segment..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"shared mem address: %p [0..%d]\n"</span><span class="token punctuation">,</span> memptr<span class="token punctuation">,</span> ByteSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"backing file:       /dev/shm%s\n"</span><span class="token punctuation">,</span> BackingFile <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* semaphore code to lock the shared mem */</span>  <span class="token class-name">sem_t</span><span class="token operator">*</span> semptr <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span>SemaphoreName<span class="token punctuation">,</span> <span class="token comment">/* name */</span>                           O_CREAT<span class="token punctuation">,</span>       <span class="token comment">/* create the semaphore */</span>                           AccessPerms<span class="token punctuation">,</span>   <span class="token comment">/* protection perms */</span>                           <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* initial value */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>semptr <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">report_and_exit</span><span class="token punctuation">(</span><span class="token string">"sem_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Why-shared-mempory-is-fastest"><a href="#Why-shared-mempory-is-fastest" class="headerlink" title="Why shared mempory is fastest"></a>Why shared mempory is fastest</h4><ul><li><p>Server reads from the input file.</p></li><li><p>The server writes this data in a message using either a pipe, fifo or message queue.</p></li><li><p>The client reads the data from the IPC channel,again requiring the data to be copied from kernel’s IPC buffer to the client’s buffer.</p></li><li><p>Finally the data is copied from the client’s buffer.</p><p>A total of four copies of data are required (2 read and 2 write). So, shared memory provides a way by letting two or more processes share a memory segment. With Shared Memory the data is only copied twice – from input file into shared memory and from shared memory to the output file.</p></li></ul><h3 id="Pipes-Anonymous-and-FIFO"><a href="#Pipes-Anonymous-and-FIFO" class="headerlink" title="Pipes (Anonymous and FIFO)"></a>Pipes (Anonymous and FIFO)</h3><ul><li><p>Through FILEs! Independent of processes.</p></li><li><p>Limited to <strong>64KB</strong>, reader and writer are fixed. May block if empty for reader, full for writer.</p></li><li><p>Anonymous pipes can be used as files, only between Parent processes and child processes.</p><ul><li><a href="https://www.geeksforgeeks.org/c-program-demonstrate-fork-and-pipe/">https://www.geeksforgeeks.org/c-program-demonstrate-fork-and-pipe/</a></li></ul></li><li><p>Named pipes are FIFO. Supported between any 2 processes. </p></li><li><p>The UNIX domain sockets(AF_UNIX), anonymous pipes and FIFOs are similar in the fact they use shared memory segments. </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="Message-queues"><a href="#Message-queues" class="headerlink" title="Message queues"></a>Message queues</h3><p>A message queue is a linked list of messages stored within the kernel and identified by a message queue identifier.</p><p>A new queue is created or an existing queue opened by <strong>msgget()</strong>.<br>New messages are added to the end of a queue by <strong>msgsnd()</strong>. Messages are fetched from a queue by <strong>msgrcv()</strong>. </p><p>We don’t have to fetch the messages in a first-in, first-out order. Instead, we can fetch messages based on their type field.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">long</span> mtype<span class="token punctuation">;</span>   <span class="token keyword">char</span> mtext<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>If msgtype is 0</strong> − Reads the first received message in the queue</li><li><strong>If msgtype is +ve</strong> − Reads the first message in the queue of type msgtype (if msgtype is 10, then reads only the first message of type 10 even though other types may be in the queue at the beginning)</li><li><strong>If msgtype is –ve</strong> − Reads the first message of lowest type less than or equal to the absolute value of message type (say, if msgtype is -5, then it reads first message of type less than 5 i.e., message type from 1 to 5)</li></ul><h3 id="Unix-domain-Sockets"><a href="#Unix-domain-Sockets" class="headerlink" title="Unix domain Sockets"></a>Unix domain Sockets</h3><p>IPC sockets (aka Unix domain sockets) enable channel-based communication for processes on the same physical device, in particular, IPC sockets communicate using a local file as a socket address.</p><p>To obtain a pair of connected sockets for two-way stream communication, you call the <a href="http://www.qnx.com/developers/docs/qnx_4.25_docs/tcpip50/prog_guide/libs/socketpair.html"><em>socketpair()</em></a> function. This function takes as arguments a domain, a style of communication, and a protocol; these arguments are shown in the following example.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> saun<span class="token punctuation">,</span> fsaun<span class="token punctuation">;</span>saun<span class="token punctuation">.</span>sun_family <span class="token operator">=</span> AF_UNIX<span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>saun<span class="token punctuation">.</span>sun_path<span class="token punctuation">,</span> ADDRESS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_UNIX<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"server: socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>saun<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"server: bind"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*     * Accept connections.  When we accept one, ns     * will be connected to the client.  fsaun will     * contain the address of the client.     */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ns <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fsaun<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fromlen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"server: accept"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><p>A <strong>signal</strong> is a notification to a process indicating the occurrence of an event. Signal is also called <strong>software interrupt</strong> and is not predictable to know its occurrence, hence it is also called an <strong>asynchronous event</strong>.</p><p>The signals which can’t be either ignored or handled/caught are SIGSTOP and SIGKILL.</p><ul><li>Default Action</li><li>Handle the signal</li><li>Block the signals</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oldact<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sighandler_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">sighandler_t</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token class-name">sighandler_t</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Kernel-threads-and-User-threads"><a href="#Kernel-threads-and-User-threads" class="headerlink" title="Kernel threads and User threads"></a>Kernel threads and User threads</h3><p>Note that user threads can block entire processes in system calls.</p><p><img src="https://www.tutorialspoint.com/operating_system/images/thread_processes.jpg" alt="Single vs Multithreaded Process"></p><h2 id="Syscalls-for-a-socket’s-lifecycle"><a href="#Syscalls-for-a-socket’s-lifecycle" class="headerlink" title="Syscalls for a socket’s lifecycle"></a>Syscalls for a socket’s lifecycle</h2><p><img src="https://pic4.zhimg.com/80/v2-a87a0d687823b3f2910e1bbe2fb04aa7_720w.jpg" alt="img"></p><p>Or we can use strace.</p><h2 id="When-do-we-get-from-Userspace-to-kernel-space"><a href="#When-do-we-get-from-Userspace-to-kernel-space" class="headerlink" title="When do we get from Userspace to kernel space"></a>When do we get from Userspace to kernel space</h2><p>syscalls, exceptions and interrupts.</p><h2 id="Linux-port-range"><a href="#Linux-port-range" class="headerlink" title="Linux port range"></a>Linux port range</h2><p>16-bit.</p><p>Under 1024 is reserverd by system，1024-65535 is for users.</p><h2 id="IO-models"><a href="#IO-models" class="headerlink" title="IO models"></a>IO models</h2><h3 id="I-O-Multiplexing-Model-select-and-poll"><a href="#I-O-Multiplexing-Model-select-and-poll" class="headerlink" title="I/O Multiplexing Model (select and poll)"></a>I/O Multiplexing Model (select and poll)</h3><p>We block in a call to <code>select</code>, waiting for the datagram socket to be readable. When <code>select</code> returns that the socket is readable, we then call <code>recvfrom</code> to copy the datagram into our application buffer.</p><h3 id="Blocking-I-O-Model"><a href="#Blocking-I-O-Model" class="headerlink" title="Blocking I/O Model"></a>Blocking I/O Model</h3><h3 id="Non-blocking-I-O-Model"><a href="#Non-blocking-I-O-Model" class="headerlink" title="Non-blocking I/O Model"></a>Non-blocking I/O Model</h3><p>Immediately returns an error instead. Put the process to sleep, need polling.</p><h3 id="Signal-Driven-I-O-Model-SIGIO"><a href="#Signal-Driven-I-O-Model-SIGIO" class="headerlink" title="Signal Driven I/O Model( SIGIO )"></a>Signal Driven I/O Model( SIGIO )</h3><p>Kernel notify user process with SIGIO signal when descriptor is ready, install a signal handler using the <code>sigaction</code> system call.</p><h3 id="Asynchronous-I-O-Model-the-POSIX-aio-functions"><a href="#Asynchronous-I-O-Model-the-POSIX-aio-functions" class="headerlink" title="Asynchronous I/O Model(the POSIX aio_functions)"></a>Asynchronous I/O Model(the POSIX <code>aio_</code>functions)</h3><p>In general, these functions work by telling the kernel to start the operation and to notify us when the entire operation (including the copy of the data from the kernel to our buffer) is complete. The main difference between this model and the signal-driven I/O model in the previous section is that with signal-driven I/O, the kernel tells us when an I/O operation can be <em>initiated</em>, but with asynchronous I/O, the kernel tells us when an I/O operation is <em>complete</em>.</p><p><img src="https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/files/06fig06.gif" alt="graphics/06fig06.gif"></p><h3 id="Synchronous-I-O-versus-Asynchronous-I-O"><a href="#Synchronous-I-O-versus-Asynchronous-I-O" class="headerlink" title="Synchronous I/O versus Asynchronous I/O"></a>Synchronous I/O versus Asynchronous I/O</h3><p>Blocking, nonblocking, I/O multiplexing, and signal-driven I/O—are all synchronous because the actual I/O operation (<code>recvfrom</code>) blocks the process. </p><p>Only the asynchronous I/O model matches the asynchronous I/O definition.</p><h2 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h2><ul><li>Mutual exclusion: processes require exclusive control of its resources (not sharing). </li><li>Hold and wait: process may wait for a resource while holding others.</li><li>No preemption: process will not give up a resource until it is finished with it. Also, processes are irreversible: unable to reset to an earlier state where resources not held. </li><li>Circular wait: each process in the chain holds a resource requested by another</li></ul><h2 id="Critical-Section"><a href="#Critical-Section" class="headerlink" title="Critical Section"></a>Critical Section</h2><p>The critical section is <strong>a code segment where the shared variables can be accessed</strong>. An atomic action is required in a critical section i.e. only one process can execute in its critical section at a time. All the other processes have to wait to execute in their critical sections.</p><h4 id="CLI-STI-single-cpu"><a href="#CLI-STI-single-cpu" class="headerlink" title="CLI, STI single cpu"></a>CLI, STI single cpu</h4><h2 id="About-fork-and-exec"><a href="#About-fork-and-exec" class="headerlink" title="About fork() and exec()"></a>About fork() and exec()</h2><h3 id="Context-Switch-from-Kernel-to-User"><a href="#Context-Switch-from-Kernel-to-User" class="headerlink" title="Context Switch from Kernel to User"></a>Context Switch from Kernel to User</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// save parent process's ebp</span><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>  <span class="token string">"movl %%ebp, %0"</span>  <span class="token operator">:</span><span class="token string">"=r"</span> <span class="token punctuation">(</span>pcb<span class="token operator">-></span>parent_ebp<span class="token punctuation">)</span>  <span class="token operator">:</span>  <span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">,</span> <span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mmap_user</span><span class="token punctuation">(</span>pcb<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// prepare for context switch</span>tss<span class="token punctuation">.</span>esp0 <span class="token operator">=</span> <span class="token function">get_esp0</span><span class="token punctuation">(</span>pcb<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* the order to push are as follows:       0 | ss (USER_DS)       esp  (132MB USER_STACK_BASE)       eflags (pushfl)       0 | cs (USER_CS)       %eip iret*/</span><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"                  \n\            pushl %%eax              \n\            pushl %%ebx              \n\            pushfl                  \n\            pushl %%edx              \n\            pushl %%ecx              \n\            iret                    \n\            "</span>                           \              <span class="token operator">:</span>                           \              <span class="token operator">:</span> <span class="token string">"a"</span><span class="token punctuation">(</span>USER_DS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">(</span>USER_STACK_BASE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">(</span>USER_CS<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">(</span>user_eip<span class="token punctuation">)</span>  \              <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">,</span> <span class="token string">"cc"</span>            \<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Syscall-exit"><a href="#Syscall-exit" class="headerlink" title="Syscall exit()"></a>Syscall exit()</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">tss<span class="token punctuation">.</span>esp0 <span class="token operator">=</span> <span class="token function">get_esp0</span><span class="token punctuation">(</span>parent_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// restore parent paging</span><span class="token function">mmap_user</span><span class="token punctuation">(</span>parent_pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//delete_pid(child_pcb);</span><span class="token comment">// jump to execture return</span><span class="token comment">// restore parent process's ebp</span><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>  <span class="token string">"movl %0, %%ebp ;"</span>  <span class="token string">"andl $0x000000FF, %%eax ;"</span>  <span class="token string">"leave  ;"</span>  <span class="token string">"ret  ;"</span>  <span class="token operator">:</span>  <span class="token operator">:</span> <span class="token string">"b"</span> <span class="token punctuation">(</span>child_pcb<span class="token operator">-></span>parent_ebp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"a"</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span> status<span class="token punctuation">)</span>  <span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">,</span> <span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h2><p>There are two categories of semaphores i.e. <strong>Counting semaphores</strong> and <strong>Binary semaphores</strong>.</p><p>In <strong>Counting semaphores</strong>, firstly, the semaphore variable is initialized with the number of resources available. After that, whenever a process needs some resource, then the wait() function is called and the value of the semaphore variable is decreased by one. The process then uses the resource and after using the resource, the signal() function is called and the value of the semaphore variable is increased by one. </p><h3 id="Mutex-and-Sempahore-usage-differences"><a href="#Mutex-and-Sempahore-usage-differences" class="headerlink" title="Mutex and Sempahore usage differences"></a>Mutex and Sempahore usage differences</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Task 2 */</span>   <span class="token function">mutexWait</span><span class="token punctuation">(</span>mutex_mens_room<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// Safely use shared resource</span>   <span class="token function">mutexRelease</span><span class="token punctuation">(</span>mutex_mens_room<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>By contrast, you should always use a semaphore like this:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Task 1 - Producer */</span>    <span class="token function">sem_signal</span><span class="token punctuation">(</span>sem_power_btn<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Send the signal</span><span class="token comment">/* Task 2 - Consumer */</span>    <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem_power_btn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Wait for signal</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Importantly, semaphores can also be used to signal from an interrupt service routine (ISR) to a task. Signaling a semaphore is a non-blocking RTOS(real-time operating system ) behavior and thus ISR safe. Because this technique eliminates the error-prone need to disable interrupts at the task level, signaling from within an ISR is an excellent way to make embedded software more reliable by design.</p><h5 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep."></a>Sleep.</h5><h3 id="Physical-Address-and-Virtual-Address"><a href="#Physical-Address-and-Virtual-Address" class="headerlink" title="Physical Address and Virtual Address"></a>Physical Address and Virtual Address</h3><p>Contiguously allocate memory, avoid fragmentation, permission isolation.</p><p>The bottom 2 GB of the address space is for user processes, while the top 2 GB is for the kernel. The kernel address space is statically mapped into the address space. The top 1 GB of the user’s space is reserved for system elements while the bottom 1 GB holds the user code, data, stack, and heap.</p><h3 id="Page-Tables"><a href="#Page-Tables" class="headerlink" title="Page Tables"></a>Page Tables</h3><h4 id="PDE-PTE"><a href="#PDE-PTE" class="headerlink" title="PDE PTE"></a>PDE PTE</h4><p>The page table is where the operating system stores its mappings of virtual addresses to physical addresses, with each mapping also known as a <em>page table entry</em> (PTE).</p><h4 id="TLB-from-MMU"><a href="#TLB-from-MMU" class="headerlink" title="TLB from MMU"></a>TLB from MMU</h4><h3 id="Page-Faults"><a href="#Page-Faults" class="headerlink" title="Page Faults"></a>Page Faults</h3><p>The page table lookup may fail, triggering a <a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a>, for two reasons:</p><ul><li>The lookup may fail if there is no translation available for the virtual address, meaning that virtual address is invalid. It will cause a <a href="https://en.wikipedia.org/wiki/Segmentation_fault">segmentation fault</a> signal being sent to the offending program.</li><li>The lookup may also fail if the page is currently not resident in physical memory. This will occur if the requested page has been <a href="https://en.wikipedia.org/wiki/Paging">moved out</a> of physical memory to make room for another page. A similar mechanism is used for <a href="https://en.wikipedia.org/wiki/Memory-mapped_file">memory-mapped files</a>, which are mapped to virtual memory and loaded to physical memory on demand.</li></ul><h4 id="Memory-mapped-file"><a href="#Memory-mapped-file" class="headerlink" title="Memory-mapped file"></a>Memory-mapped file</h4><p><strong>More precisely, a memory mapped file is a mirror of a portion (or entire) file on virtual memory managed completely by the operating system</strong>.</p><p>In other words, whenever a file is memory mapped, the operating system will immediately map file memory to a region on virtual memory. You can think of this as some RAM space. Whenever the OS dumps the file content to disk (to accommodate another task) a <a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a> can happen. That’s when the OS goes back and reloads content back to the RAM. </p><h4 id="There-are-two-types-of-memory-mapped-files"><a href="#There-are-two-types-of-memory-mapped-files" class="headerlink" title="There are two types of memory-mapped files:"></a>There are two types of memory-mapped files:</h4><ul><li><p>Persisted memory-mapped files</p><p>Persisted files are memory-mapped files that are associated with a source file on a disk. When the last process has finished working with the file, the data is saved to the source file on the disk. These memory-mapped files are suitable for working with extremely large source files.</p></li><li><p>Non-persisted memory-mapped files</p><p>Non-persisted files are memory-mapped files that are not associated with a file on a disk. When the last process has finished working with the file, the data is lost and the file is reclaimed by garbage collection. These files are suitable for creating shared memory for inter-process communications (IPC).</p></li></ul><h2 id="Reading-from-Block-devices"><a href="#Reading-from-Block-devices" class="headerlink" title="Reading from Block devices"></a>Reading from Block devices</h2><ol><li>invoke call to VFS read and call read for block devices</li><li>Each block requires its own <em>block buffer</em>, which is a RAM memory area used by the kernel to store the block’s content. When the kernel reads a block from disk, it fills the corresponding block buffer with the values obtained from the hardware device; similarly, when the kernel writes a block on disk, it updates the corresponding group of adjacent bytes on the hardware device with the actual values of the associated block buffer. The size of a block buffer always matches the size of the corresponding block.</li></ol><h1 id="Page-replacement-algorithm"><a href="#Page-replacement-algorithm" class="headerlink" title="Page replacement algorithm"></a>Page replacement algorithm</h1><ol><li><strong>First In First Out (FIFO)</strong></li><li><strong>Optimal Page replacement</strong>(OPT) <ol><li> pages are replaced which would not be used for the longest duration of time in the future</li></ol></li><li><strong>Least Recently Used</strong> </li></ol><h2 id="Lifecycle-of-Processes"><a href="#Lifecycle-of-Processes" class="headerlink" title="Lifecycle of Processes"></a>Lifecycle of Processes</h2><ul><li>运行（running）态</li><li>就绪（ready）态</li><li>阻塞（wait）态</li></ul><h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><ul><li>Runnable</li><li>Blocked</li><li>Waiting</li><li>Timed Waiting</li></ul><h2 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h2><ul><li><strong>FCFS</strong></li><li>SJB</li><li><strong>RR</strong></li><li><strong>HRRN</strong>(<strong>最高响应比优先法</strong>)<ul><li><strong>R =(W+T)/T = 1+W/T</strong></li><li>T is runnint time，W is waiting time</li></ul></li><li><strong>Multilevel Feedback Queue</strong></li></ul><h2 id="Kernel-Space-User-Space-Interfaces"><a href="#Kernel-Space-User-Space-Interfaces" class="headerlink" title="Kernel Space, User Space Interfaces"></a><strong>Kernel Space, User Space Interfaces</strong></h2><h3 id="Shared-Memory-mmap）"><a href="#Shared-Memory-mmap）" class="headerlink" title="Shared Memory(mmap）"></a>Shared Memory(mmap）</h3><h3 id="Upcall"><a href="#Upcall" class="headerlink" title="Upcall"></a>Upcall</h3><p>Allows a kernel module to invoke a function in user space. It is possible to start a program in user space, and give it some command line arguments, as well as setting environment variables.</p><h3 id="Ioctl"><a href="#Ioctl" class="headerlink" title="Ioctl"></a>Ioctl</h3><p>The ioctl mechanism is implemented as a single system call which multiplexes the different commands to the appropriate kernel space function. A call to ioctl has three arguments: a file (or socket) descriptor, a number identifying the command, and a data argument. </p><h3 id="System-Calls"><a href="#System-Calls" class="headerlink" title="System Calls"></a>System Calls</h3><h3 id="Signals-1"><a href="#Signals-1" class="headerlink" title="Signals"></a>Signals</h3><p>install a signal handler using the <code>sigaction</code> system call?</p><h3 id="Character-Devices"><a href="#Character-Devices" class="headerlink" title="Character Devices"></a>Character Devices</h3><p>Each module can register itself as a character device and provide some read and write functions which handle the data. </p><h3 id="Filesystem"><a href="#Filesystem" class="headerlink" title="Filesystem"></a>Filesystem</h3><h4 id="Procfs-proc"><a href="#Procfs-proc" class="headerlink" title="Procfs(/proc)"></a>Procfs(/proc)</h4><p>Virtual files provide information about the running system such as cpu information, information about interrupts, about the available memory or the version of the kernel, devices. Networking information such as the arp table, network statistics or lists of used sockets.</p><h5 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h5><p>Sysctl is used to modify kernel parameters at runtime. </p><p>Each entry in the /proc/sys directory is represented by an entry in a table maintained by the Linux kernel, arranged in a hierarchy. A directory is represented by an entry pointing to a subtable. A file is represented by an entry of type struct ctl_table. This entry consists of the data represented by this file along with some access rules.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sysctl vm.swappinesssysctl -w net.ipv4.ip_forward&#x3D;1sbin&#x2F;sysctl -a&#x2F;sbin&#x2F;sysctl -n kernel.hostname&#x2F;sbin&#x2F;sysctl -w kernel.domainname&#x3D;&quot;example.com&quot;&#x2F;sbin&#x2F;sysctl -p&#x2F;etc&#x2F;sysctl.conf&#x2F;sbin&#x2F;sysctl -a --pattern forward&#x2F;sbin&#x2F;sysctl -a --pattern forward$&#x2F;sbin&#x2F;sysctl -a --pattern &#39;net.ipv4.conf.(eth|wlan)0.arp&#39;&#x2F;sbin&#x2F;sysctl  --pattern &#39;^net.ipv6&#39; --system&#x2F;proc&#x2F;sys&#x2F;etc&#x2F;sysctl.d&#x2F;*.conf&#x2F;run&#x2F;sysctl.d&#x2F;*.conf&#x2F;usr&#x2F;local&#x2F;lib&#x2F;sysctl.d&#x2F;*.conf&#x2F;usr&#x2F;lib&#x2F;sysctl.d&#x2F;*.conf&#x2F;lib&#x2F;sysctl.d&#x2F;*.conf&#x2F;etc&#x2F;sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Seq-file-lt-linux-seq-file-h-gt"><a href="#Seq-file-lt-linux-seq-file-h-gt" class="headerlink" title="Seq_file(&lt;linux/seq_file.h&gt;)"></a>Seq_file(&lt;linux/seq_file.h&gt;)</h4><p>There are numerous ways for a device driver (or other kernel component) to provide information to the user or system administrator. One useful technique is the creation of virtual files, in debugfs, /proc or elsewhere.</p><p>The seq_file interface is available via &lt;linux/seq_file.h&gt;. There are three aspects to seq_file:</p><blockquote><ul><li>An iterator interface which lets a virtual file implementation step through the objects it is presenting.</li><li>Some utility functions for formatting objects for output without needing to worry about things like output buffers.</li><li>A set of canned file_operations which implement most operations on the virtual file.</li></ul></blockquote><h4 id="Sysfs"><a href="#Sysfs" class="headerlink" title="Sysfs"></a>Sysfs</h4><p>Sysfs was designed to represent the whole device model as seen from the Linux kernel which would then no longer clutter up procfs. It contains information about devices, drivers and buses and their interconnections.</p><p>Famous APIs:</p><p><strong>new fs/ entry</strong></p><p><strong>new bus/ entry</strong></p><ul><li>sys/block/ all known block devices such as hda/ ram/ sda/</li><li>sys/bus/ all registered buses. Each directory below bus/ holds by default two subdirectories:<ul><li>device/ for all devices attached to that bus o driver/ for all drivers assigned with that bus.</li></ul></li><li>sys/class/ for each device type there is a subdirectory: for example /printer or /sound</li><li>sys/device/ all devices known by the kernel, organised by the bus they are connected to</li><li>sys/firmware/ files in this directory handle the firmware of some hardware devices</li><li>sys/fs/ files to control a file system, currently used by FUSE, a user space file system implementation</li><li>sys/kernel/ holds directories (mount points) for other filesystems such as debugfs, securityfs.</li><li>sys/module/ each kernel module loaded is represented with a directory.</li><li>sys/power/ files to handle the power state of some hardware</li></ul><h4 id="Configfs"><a href="#Configfs" class="headerlink" title="Configfs"></a>Configfs</h4><p>An important difference between configfs and sysfs is that in configfs all objects are created from user space with a call to mkdir(2). The kernel responds with creating the attributes (files) and then they can be read and written by the user. If the user no longer needs the files, he calls rmdir(2) and everything gets deleted. Therefore the life cycle of a configfs object is fully controlled by user space.</p><h4 id="debugfs"><a href="#debugfs" class="headerlink" title="debugfs"></a>debugfs</h4><p>RAM-based file system specially designed for debugging purposes. The debugfs program is an interactive file system debugger. It can be used to examine  and change the state of an ext2, ext3, or ext4 file system.</p><h3 id="Socket-Based-Mechanisms"><a href="#Socket-Based-Mechanisms" class="headerlink" title="Socket Based Mechanisms"></a>Socket Based Mechanisms</h3><p><strong>AF_INET</strong>: designed for network communication, but UDP sockets can also be used for the communication between a kernel module and the user space. The use of UDP sockets for node local communication involves a lot of overhead.</p><p><strong>AF_PACKET</strong>: allows the user to define all packet headers.</p><p><strong>AF_NETLINK</strong> (netlink sockets): They are especially designed for the communication between the kernel space and the user space.  It makes use of the standard socket APIs for user-space processes, and a special kernel API for kernel modules. There are different netlink socket types currently implemented in the kernel, all of which deal with a specific subset of the networking part of the Lin</p><h5 id="Netlink-sockets"><a href="#Netlink-sockets" class="headerlink" title="Netlink sockets"></a>Netlink sockets</h5><p>Netlink sockets have the following advantages over other communication mechanisms:</p><ul><li>It is simple to interact with the standard Linux kernel as only a constant has to be added to the Linux kernel source code. There is no risk to pollute the kernel or to drive it in instability, since the socket can immediately be used.</li><li>Netlink sockets are asynchronous as they provide queues, meaning they do not disturb kernel scheduling. </li><li>Netlink sockets provide the possibility of multicast.</li><li>Netlink sockets provide a truly bidirectional communication channel</li><li>They have less overhead (header and processing) compared to standard UDP sockets.</li></ul><p>Beside these advantages netlink sockets have two drawbacks:</p><ul><li>Each entity using netlink sockets has to define its own protocol type (family) in the kernel header file include/linux/netlink.h, necessiating a kernel re-compilation before it can be used.</li><li>The maximum number of netlink families is fixed to 32. If everyone registers its own protocol this number will be exhausted.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Processes-and-Threads&quot;&gt;&lt;a href=&quot;#Processes-and-Threads&quot; class=&quot;headerlink&quot; title=&quot;Processes and Threads&quot;&gt;&lt;/a&gt;Processes and Threads&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++ Interview Prep</title>
    <link href="https://anxue.xyz/blog/2021/C-InterviewPrep/"/>
    <id>https://anxue.xyz/blog/2021/C-InterviewPrep/</id>
    <published>2021-08-12T12:05:05.000Z</published>
    <updated>2021-08-12T12:10:32.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="char-const-amp-const-char"><a href="#char-const-amp-const-char" class="headerlink" title="char * const  &amp; const char *"></a>char * const  &amp; const char *</h2><p>The difference is that <code>const char *</code> is a pointer to a <code>const char</code>, while <code>char * const</code> is a constant pointer to a <code>char</code>.</p><p><code>const char *</code> and <code>char const *</code> are equivalent.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span>       <span class="token operator">*</span>      mutable_pointer_to_mutable_int<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span>      mutable_pointer_to_constant_int<span class="token punctuation">;</span><span class="token keyword">int</span>       <span class="token operator">*</span><span class="token keyword">const</span> constant_pointer_to_mutable_int<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span><span class="token keyword">const</span> constant_pointer_to_constant_int<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Shared-Pointer-amp-Cyclic-Reference"><a href="#Shared-Pointer-amp-Cyclic-Reference" class="headerlink" title="Shared Pointer &amp; Cyclic Reference"></a>Shared Pointer &amp; Cyclic Reference</h2><p>Use <code>weak_ptr</code>.  Lets say <code>A</code> owns <code>B</code> but <code>B</code> does not own <code>A</code> then we replace the reference to <code>A</code> in <code>B</code> with a <code>weak_ptr</code></p><h3 id="unique-ptr、shared-ptr-and-weak-ptr"><a href="#unique-ptr、shared-ptr-and-weak-ptr" class="headerlink" title="unique_ptr、shared_ptr and weak_ptr."></a>unique_ptr、shared_ptr and weak_ptr.</h3><h4 id="Reference-Count"><a href="#Reference-Count" class="headerlink" title="Reference Count"></a>Reference Count</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::shared_ptr p1(new int());p1.use_count();p1.reset();p1.reset(new int(34)); or p1 &#x3D; nullptr; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Why-auto-ptr-is-banned"><a href="#Why-auto-ptr-is-banned" class="headerlink" title="Why auto_ptr is banned"></a>Why auto_ptr is banned</h4><p>The <strong>copy semantics</strong> of <code>auto_ptr</code> are not compatible with the containers.</p><p>Specifically, copying one <code>auto_ptr</code> to another does not create two equal objects since one has lost its ownership of the pointer.</p><h2 id="Constructors-the-big-4"><a href="#Constructors-the-big-4" class="headerlink" title="Constructors, the big 4"></a>Constructors, the big 4</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace cs225 &#123;  class String &#123;  private:      char* s;      int size;  public:    &#x2F;&#x2F; const variables must be initialized using Initializer List    &#x2F;&#x2F; Reference members must be initialized using Initializer List.    &#x2F;&#x2F; For initialization of member objects which do not have default constructor    String():s(NULL), size(5)&#123;&#125;      String(char*); &#x2F;&#x2F; constructor    String(const String s&amp;);      ~String(); &#x2F;&#x2F; destructor,     String&amp; operator&#x3D;(const String&amp; b) &#x2F;&#x2F; Copy assignment operator      &#123;          x &#x3D; b.x;          return *this;      &#125;    &#x2F;&#x2F; operator&#x3D; ( const String&amp;) &#x3D; default;    &#x2F;&#x2F; operator&#x3D; ( const String&amp;) &#x3D; delete;  &#125;;&#125;String::String(char* c)&#123;    size &#x3D; strlen(c);    s &#x3D; new char[size + 1];    strcpy(s, c);&#125;String::~String() &#123; delete[] s; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Copy constructor is called when a new object is created from an existing object, as a copy of the existing object.</li><li>Assignment operator is called when an already initialized object is assigned a new value from another existing object.</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;     Test t1, t2;     t2 &#x3D; t1; &#x2F;&#x2F; calls assignment operator, same as &quot;t2.operator&#x3D;(t1);&quot;    Test t3 &#x3D; t1; &#x2F;&#x2F; calls copy constructor, same as &quot;Test t3(t1);&quot;    return 0; &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Initializor-List"><a href="#Initializor-List" class="headerlink" title="Initializor List"></a>Initializor List</h3><p> Initialization lists get completely executed <em>before</em> entering the constructor block.</p><ul><li>non-static const variables must be initialized using Initializer List</li><li>Reference members must be initialized using Initializer List.</li><li>For initialization of member objects which do not have default constructor<ul><li>If class A had both default and parameterized constructors, then Initializer List is not must if we want to initialize “a” using default constructor, but it is must to initialize “a” using parameterized constructor. </li></ul></li><li>For initialization of base class members<ul><li>Like point 3, the parameterized constructor of the base class can only be called using Initializer List.</li></ul></li><li>When constructor’s parameter name is same as data member<ul><li><code>A::A(int i):i(i) &#123; &#125;</code></li></ul></li></ul><h2 id="Virtual"><a href="#Virtual" class="headerlink" title="Virtual"></a>Virtual</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Shape &#123;public:  virtual void draw() const &#x3D; 0;  &#x2F;&#x2F; &#x3D; 0 means it is &quot;pure virtual&quot;  virtual Shape* clone() const &#x3D; 0;  virtual  ~Shape();&#x2F;&#x2F; Ensures to invoke actual object destructor  &#x2F;&#x2F; virtual  ~Shape()&#123;&#125;&#125;;class Circle : public Shape &#123;public:  &#x2F;&#x2F; ...  virtual Circle* clone() const;  &#x2F;&#x2F; ...&#125;;Circle* Circle::clone() const&#123;  return new Circle(*this);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Can we make a class constructor <em>virtual</em> in C++ to create polymorphic objects?</strong> </p><p>No. C++ being statically typed (the purpose of RTTI is different) language, it is meaningless to the C++ compiler to create an object polymorphically. The compiler must be aware of the class type to create the object. </p><p>In C++, the constructor cannot be virtual, because when a constructor of a class is executed there is no virtual table in the memory, means no virtual pointer defined yet.</p><h2 id="Virtual-function-table"><a href="#Virtual-function-table" class="headerlink" title="Virtual function table"></a>Virtual function table</h2><p><img src="https://www.learncpp.com/images/CppTutorial/Section12/VTable.gif" alt="img"></p><p>First, every class that uses virtual functions (or is derived from a class that uses virtual functions) is given its own virtual table. This table is simply a static array of function pointers that the compiler sets up at compile time. Each entry points to the most-derived function accessible by that class.</p><p>Second, the compiler also adds a hidden pointer to the base class, which we will call *____vptr. *____vptr is set (automatically) when a class instance is created so that it points to the virtual table for that class. Unlike the *this pointer, which is actually a function parameter used by the compiler to resolve self-references, *____vptr is a real pointer. Consequently, it makes each class object allocated bigger by the size of one pointer. It also means that *____vptr is inherited by derived classes, which is important.</p><h3 id="Polymorphism-in-C"><a href="#Polymorphism-in-C" class="headerlink" title="Polymorphism in C++"></a>Polymorphism in C++</h3><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20200703160531/Polymorphism-in-CPP.png" alt="Polymorphism-in-CPP"></p><ul><li><p>Function Overloading.</p></li><li><p>Operator overloading</p></li><li><p>Runtime Polymorphism: Function overriding.</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;main functionint main() &#123;    base *bptr;    derived d;    bptr &#x3D; &amp;d;           &#x2F;&#x2F;virtual function, binded at runtime (Runtime polymorphism)    bptr-&gt;print(); &#x2F;&#x2F; print derived class           &#x2F;&#x2F; Non-virtual function, binded at compile time    bptr-&gt;show(); &#x2F;&#x2F; show base class      return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Const-in-C"><a href="#Const-in-C" class="headerlink" title="Const in C++"></a>Const in C++</h2><h5 id="Const-member-functions"><a href="#Const-member-functions" class="headerlink" title="Const member functions"></a>Const member functions</h5><p>The idea of const functions is not to allow them to modify the object on which they are called.</p><h5 id="Const-Classes"><a href="#Const-Classes" class="headerlink" title="Const Classes"></a>Const Classes</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> A anInstance <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Can only call const functions.</p><h5 id="Const-variables"><a href="#Const-variables" class="headerlink" title="Const variables"></a>Const variables</h5><p>Must be initialized using Initializer List.</p><h2 id="Static-in-C"><a href="#Static-in-C" class="headerlink" title="Static in C++"></a>Static in C++</h2><h5 id="Static-variables-in-a-Function"><a href="#Static-variables-in-a-Function" class="headerlink" title="Static variables in a Function:"></a><strong>Static variables in a Function</strong>:</h5><p>When a variable is declared as static, space for <strong>it gets allocated for the lifetime of the program</strong>. </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void demo()&#123;     &#x2F;&#x2F; static variable    static int count &#x3D; 0;    count++;&#125;int main()&#123;    for (int i&#x3D;0; i&lt;5; i++)            demo();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Static-variables-in-a-class"><a href="#Static-variables-in-a-class" class="headerlink" title="Static variables in a class"></a><strong>Static variables in a class</strong></h5><p>As the variables declared as static are initialized only once as they are allocated space in separate static storage so, the static variables <strong>in a class are shared by the objects.</strong> </p><h5 id="Class-objects-as-static"><a href="#Class-objects-as-static" class="headerlink" title="Class objects as static"></a><strong>Class objects as static</strong></h5><p>Just like variables, objects also when declared as static have a scope till the lifetime of program.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static GfG obj;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="Static-functions-in-a-class"><a href="#Static-functions-in-a-class" class="headerlink" title="Static functions in a class"></a><strong>Static functions in a class</strong></h5><p><strong>Static member functions are allowed to access only the static data members or other static member functions</strong>, they can not access the non-static data members or member functions of the class.</p><h2 id="RTTI-Run-Time-Type-Information"><a href="#RTTI-Run-Time-Type-Information" class="headerlink" title="RTTI (Run-Time Type Information)"></a>RTTI (Run-Time Type Information)</h2><p>There are three main C++ language elements to run-time type information:</p><ul><li><p>The <a href="https://docs.microsoft.com/en-us/cpp/cpp/dynamic-cast-operator?view=msvc-160">dynamic_cast</a> operator.</p><ul><li><p>Used for conversion of polymorphic types.</p></li><li><p>RTTI is available only for classes that are <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">polymorphic</a>, which means they have at least one <a href="https://en.wikipedia.org/wiki/Virtual_method">virtual method</a>. (All have virtual destructor)</p></li></ul></li><li><p>The <a href="https://docs.microsoft.com/en-us/cpp/cpp/typeid-operator?view=msvc-160">typeid</a> operator.</p><ul><li>Used for identifying the exact type of an object.</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::cout &lt;&lt; typeid(person).name() &lt;&lt; std::endl;  &#x2F;&#x2F; Person (statically known at compile-time).<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>The <a href="https://docs.microsoft.com/en-us/cpp/cpp/type-info-class?view=msvc-160">type_info</a> class.</p><ul><li>Used to hold the type information returned by the <strong><code>typeid</code></strong> operator.</li></ul></li></ul><h2 id="Pure-virtual-functions-and-virtual-functions"><a href="#Pure-virtual-functions-and-virtual-functions" class="headerlink" title="Pure virtual functions and virtual functions"></a>Pure virtual functions and virtual functions</h2><ul><li>A virtual function makes its class a <em>polymorphic base class</em>.<ul><li>Virtual functions called through base class pointers/references will be resolved at run-time. </li></ul></li><li>A pure virtual function implicitly makes the class it is defined for <em>abstract</em><ul><li> Abstract classes cannot be instantiated. Derived classes need to override/implement all inherited pure virtual functions. </li></ul></li></ul><h2 id="Protected"><a href="#Protected" class="headerlink" title="Protected"></a>Protected</h2><p>Class member declared as Protected are inaccessible outside the class but they can be accessed by any subclass(derived class) of that class.</p><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><h3 id="Example-of-Blocking-Queue"><a href="#Example-of-Blocking-Queue" class="headerlink" title="Example of Blocking Queue"></a>Example of Blocking Queue</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef BLOCKINGQUEUE_H#define BLOCKINGQUEUE_H#include &lt;queue&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;template &lt;typename T&gt;class BlockingQueue&#123;public:    BlockingQueue():lk(), sig(), q()&#123;&#125;    &#x2F;&#x2F; don&#39;t allow copy ctor    BlockingQueue(const BlockingQueue&amp;) &#x3D; delete;    BlockingQueue&amp; operator&#x3D;(const BlockingQueue&amp; b) &#x3D; delete;     ~BlockingQueue()&#123;&#125;&#x2F;&#x2F; Allow rvalue reference  &#x2F;&#x2F; move constructor and move assignment    void push(T&amp;&amp; value)    &#123;      &#x2F;&#x2F; unique_lock not lk.lock()      &#x2F;&#x2F; could also use lock_guard if no need for condition_variable: std::lock_guard&lt;std::mutex&gt; guard(myMutex);        std::unique_lock&lt;std::mutex&gt; lkguard(lk); &#x2F;&#x2F; can use lkguard.unlock() if want to release early        q.push(value);        sig.notify_all();      &#x2F;&#x2F; end of life-cycle for lkguard, releases.    &#125;    void push(const T&amp; value)    &#123;        std::unique_lock&lt;std::mutex&gt; lock(lk);        q.push(value);        sig.notify_all();    &#125;  &#x2F;&#x2F; wait until queue not empty    T pop()    &#123;        std::unique_lock&lt;std::mutex&gt; lock(lk);        while(q.empty())            sig.wait(lock);        T value(std::move(q.front()));        q.pop();        return value;    &#125;    size_t size() const    &#123;        std::unique_lock&lt;std::mutex&gt; lock(lk);        return q.size();    &#125;private:    std::queue&lt;T&gt; q;    std::mutex lk;    std::condition_variable sig;&#125;;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>master 线程 （生产者）：负责往阻塞队列中塞入数据，并唤醒正在阻塞的 worker 线程。</li><li>worker 线程（消费者）：负责从阻塞队列中取数据，如果没有数据便阻塞，直到被 master 线程唤醒。</li></ul><h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;memory&gt; &#x2F;&#x2F; shared_ptr#include &lt;mutex&gt;  &#x2F;&#x2F; mutex&#x2F;&#x2F; version 2:&#x2F;&#x2F; with problems below fixed:&#x2F;&#x2F; 1. thread is safe now&#x2F;&#x2F; 2. memory doesn&#39;t leakclass Singleton&#123;public:    ~Singleton()&#123;&#125;    Singleton(Singleton&amp;)&#x3D;delete;    Singleton&amp; operator&#x3D;(const Singleton&amp;)&#x3D;delete;    static std::shared_ptr&lt;Singleton&gt; get_instance()&#123;        if(m_instance_ptr&#x3D;&#x3D;nullptr)&#123;            std::lock_guard&lt;std::mutex&gt; lk(m_mutex);            if(m_instance_ptr &#x3D;&#x3D; nullptr)&#123;              m_instance_ptr &#x3D; std::shared_ptr&lt;Singleton&gt;(new Singleton);            &#125;        &#125;        return m_instance_ptr;    &#125;private:    Singleton()&#123;&#125;    static std::shared_ptr&lt;Singleton&gt; m_instance_ptr;    static std::mutex m_mutex;&#125;;&#x2F;&#x2F; initialization static variables out of classSingleton::Ptr Singleton::m_instance_ptr &#x3D; nullptr;std::mutex Singleton::m_mutex;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Singleton &#123;private:   static Singleton *instance;   int data;    &#x2F;&#x2F; Private constructor so that no objects can be created.   Singleton() &#123;      data &#x3D; 0;   &#125;  public:   static Singleton *getInstance() &#123;      if (!instance)      instance &#x3D; new Singleton;      return instance;   &#125;   int getData() const &#123;      return this -&gt; data;   &#125;   void setData(int data) &#123;      this -&gt; data &#x3D; data;   &#125;&#125;;&#x2F;&#x2F;Initialize pointer to zero so that it can be initialized in first call to getInstanceSingleton *Singleton::instance &#x3D; 0;int main()&#123;   Singleton *s &#x3D; s-&gt;getInstance();   cout &lt;&lt; s-&gt;getData() &lt;&lt; endl;   s-&gt;setData(100);   cout &lt;&lt; s-&gt;getData() &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="STL-sort"><a href="#STL-sort" class="headerlink" title="STL sort"></a>STL sort</h2><p>The algorithm used by sort() is <a href="https://www.geeksforgeeks.org/know-your-sorting-algorithm-set-2-introsort-cs-sorting-weapon/"><strong>IntroSort</strong></a>. Introsort being a hybrid sorting algorithm uses three sorting algorithm to minimize the running time, <a href="https://www.geeksforgeeks.org/quick-sort/">Quicksort</a>, <a href="https://www.geeksforgeeks.org/heap-sort/">Heapsort</a> and <a href="https://www.geeksforgeeks.org/insertion-sort/">Insertion Sort</a>. Simply putting, it is the best sorting algorithm around. It is a hybrid sorting algorithm, which means that it uses more than one sorting algorithms as a routine. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;char-const-amp-const-char&quot;&gt;&lt;a href=&quot;#char-const-amp-const-char&quot; class=&quot;headerlink&quot; title=&quot;char * const  &amp;amp; const char *&quot;&gt;&lt;/a&gt;char</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Modern-Philosophy</title>
    <link href="https://anxue.xyz/blog/2021/Modern-Philosophy/"/>
    <id>https://anxue.xyz/blog/2021/Modern-Philosophy/</id>
    <published>2021-05-27T14:13:28.000Z</published>
    <updated>2021-05-27T14:42:05.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Branches-of-Philosophy"><a href="#Branches-of-Philosophy" class="headerlink" title="Branches of Philosophy"></a><strong>Branches of Philosophy</strong></h2><h3 id="Metaphysics"><a href="#Metaphysics" class="headerlink" title="Metaphysics"></a>Metaphysics</h3><ul><li>Ontology (study of being) 本体论</li><li>Cosmology (study of the world)</li><li>Anthropology (study of humanity) to Psychology (study of the human soul) </li><li>Theology (study of God)</li></ul><h3 id="Epistemology"><a href="#Epistemology" class="headerlink" title="Epistemology"></a>Epistemology</h3><p>认识论</p><h3 id="Axiology-Ethics-价值论"><a href="#Axiology-Ethics-价值论" class="headerlink" title="Axiology: Ethics 价值论"></a>Axiology: Ethics 价值论</h3><p> 美学+道德</p><p>Meta-Ethics  善恶</p><p>Normative Ethics:  ought to be good/bad</p><p> Applied Ethics: social<br> Descriptive Ethics: what decribes good<br> Political Philosophy<br> Philosophy of Law/Philosophy of Right</p><h3 id="Axiology-Aesthetics"><a href="#Axiology-Aesthetics" class="headerlink" title="Axiology: Aesthetics"></a>Axiology: Aesthetics</h3><h3 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h3><h2 id="Schools-Types-of-Philosophy"><a href="#Schools-Types-of-Philosophy" class="headerlink" title="Schools/Types of Philosophy"></a><strong>Schools/Types of Philosophy</strong></h2><h4 id="Rationalism"><a href="#Rationalism" class="headerlink" title="Rationalism"></a>Rationalism</h4><p>The epistemological presupposition that rational certainty about our thought processes provides the ground whereupon we can make sense of the external world that we empirically observe</p><ul><li>Intuition-Deduction Thesis </li><li>Innate Knowledge Thesis </li><li>Innate Ideas Thesis</li></ul><h4 id="Empiricism"><a href="#Empiricism" class="headerlink" title="Empiricism"></a>Empiricism</h4><p>The epistemological presupposition that sensory experience is the primary or even only source of knowledge</p><ul><li><p><em>Tabula-rasa</em> school</p></li><li><p>Berkeleian school (empirical idealism)</p></li><li><p>Humean school (skepticism) </p></li></ul><h4 id="Kantianism"><a href="#Kantianism" class="headerlink" title="Kantianism"></a>Kantianism</h4><p>Transcendental idealism (empirical realism &amp; formal idealism) </p><h4 id="Libertarianism"><a href="#Libertarianism" class="headerlink" title="Libertarianism"></a>Libertarianism</h4><h4 id="Communitarianism"><a href="#Communitarianism" class="headerlink" title="Communitarianism"></a>Communitarianism</h4><h2 id="René-Descartes"><a href="#René-Descartes" class="headerlink" title="René Descartes"></a>René Descartes</h2><ul><li>Method of doubt/methodological skepticism</li><li><em>Cogito ergo sum</em> (I think, therefore I am)</li></ul><h4 id="Ontological-proof"><a href="#Ontological-proof" class="headerlink" title="Ontological proof"></a>Ontological proof</h4><ul><li>“Perfect being”: perfection entails existence</li><li>The notion of a perfect being that lacks existence is self-contradictory (for the lack of existence is an imperfection)</li><li>Such a notion is analogous to the conception of a triangle whose interior angles do not add up to 180 degrees</li><li>On the basis of cogito ergo sum: the perfect being must exist</li></ul><h4 id="Wax-argument"><a href="#Wax-argument" class="headerlink" title="Wax argument"></a>Wax argument</h4><p>Wax Argument: “ And so something that I thought I was seeing with my eyes is in fact grasped solely by the faculty of judgment which is in my mind.”</p><h4 id="Theory-of-ideas"><a href="#Theory-of-ideas" class="headerlink" title="Theory of ideas"></a>Theory of ideas</h4><p>fictitious ideas, empirical ideas, and innate ideas</p><h2 id="Baruch-Spinoza"><a href="#Baruch-Spinoza" class="headerlink" title="Baruch Spinoza"></a>Baruch Spinoza</h2><h4 id="Substance"><a href="#Substance" class="headerlink" title="Substance"></a>Substance</h4><h4 id="Pantheism-泛神论-God-nature"><a href="#Pantheism-泛神论-God-nature" class="headerlink" title="Pantheism 泛神论 (God = nature)"></a>Pantheism 泛神论 (God = nature)</h4><ul><li>denial of the divine creation of the universe</li><li>God has infinitely many attributes —-&gt; 2 important attributes: thought and extension</li></ul><h4 id="Determinism"><a href="#Determinism" class="headerlink" title="Determinism"></a>Determinism</h4><ul><li>All things are determined by Nature to exist in a chain of necessary causes and effects<br>—–&gt;denial of divine providence</li><li> “hard” determinism: all things happen by (causal) necessity</li></ul><h4 id="Psychological-freedom"><a href="#Psychological-freedom" class="headerlink" title="Psychological freedom"></a>Psychological freedom</h4><ul><li>Determinism: in one sense, all human actions are predetermined and cannot escape the universal chain of causes and effectsà human beings have no freedom</li><li>In another sense, humans can be free, when they understand the causes of their emotions and make rational choices ——&gt; reason cannot overcome emotions, but emotions can be ordered by reason to attain happiness</li><li>Moral relativism ——-&gt; path to consequentialism?</li></ul><h2 id="G-W-Leibniz"><a href="#G-W-Leibniz" class="headerlink" title="G. W. Leibniz"></a>G. W. Leibniz</h2><h4 id="Fundamental-Principles-of-Philosophy"><a href="#Fundamental-Principles-of-Philosophy" class="headerlink" title="Fundamental Principles of Philosophy"></a>Fundamental Principles of Philosophy</h4><ol><li>Identity/Contradiction (traditional law of logic)</li><li>Identity of indiscernibles (think: the identity of electrons in QM)</li><li>Sufficient reason (“There must be sufficient reason for anything to exist, for any event to occur, for any truth to obtain”) 4. Pre-established harmony (explained in terms of “monadology”)</li><li>Pre-established harmony (explained in terms of “monadology”)</li><li>Law of Continuity (“whatever succeeds for the finite, also succeeds for the infinite”: inspired by Kepler’s view of a circle as an infinite-sided polygonàinfinitesimal calculus)</li><li>Optimism (“God assuredly always chooses the best”)</li><li>Plenitude (the best possible world is one in which all rational possibilities are actualized)</li></ol><h4 id="Monadology"><a href="#Monadology" class="headerlink" title="Monadology"></a>Monadology</h4><p>Monads = simple substances that constitute the “ultimate units of existence in nature</p><p>Pre-Established Harmony:<br>Each monad affects only itself, but each<br>monad is a “mirror” or the entire universe, and so different monads can appear to interact with each other in accordance with a universal harmony programmed by God</p><h2 id="John-Locke"><a href="#John-Locke" class="headerlink" title="John Locke"></a>John Locke</h2><h4 id="Tabula-rasa"><a href="#Tabula-rasa" class="headerlink" title="Tabula rasa"></a><em>Tabula rasa</em></h4><p>Tabula rasa is the theory that individuals are born without built-in mental content, and therefore all knowledge comes from experience or perception. Epistemological proponents of tabula rasa disagree with the doctrine of innatism, which holds that the mind is born already in possession of certain knowledge.</p><h4 id="Necessary-association-of-ideas"><a href="#Necessary-association-of-ideas" class="headerlink" title="Necessary association of ideas"></a>Necessary association of ideas</h4><ul><li><p>“Sensation”: the reception of sensory data that affect the state of the mind (entirely passive)</p></li><li><p>“Reflection”: the active process in which more complex ideas are produced when the mind operates upon the simpler ideas gained through sensation</p></li></ul><h4 id="State-of-nature"><a href="#State-of-nature" class="headerlink" title="State of nature"></a>State of nature</h4><ul><li>A post-lapsarian state of nature: essential nature = good, accidental nature = evil</li><li> All humans are created free and equal</li><li>Hierarchy a social invention</li><li>all humans are created equal before God in the state of nature (vs. Filmer)</li><li>liberty is bound by the moral laws of nature: e.g. we do not have the liberty to sell ourselves into slavery;</li></ul><h4 id="Equality-of-all"><a href="#Equality-of-all" class="headerlink" title="Equality of all"></a>Equality of all</h4><h4 id="Consent-to-be-governed-express-and-tacit"><a href="#Consent-to-be-governed-express-and-tacit" class="headerlink" title="Consent to be governed: express and tacit"></a>Consent to be governed: express and tacit</h4><ul><li>avoid individual biases</li><li>place individual interests in check</li><li>The Rule of Law is more effective with a government than without one</li></ul><h4 id="Unalienable-rights"><a href="#Unalienable-rights" class="headerlink" title="Unalienable rights"></a>Unalienable rights</h4><h4 id="Property-Puritan-Influences"><a href="#Property-Puritan-Influences" class="headerlink" title="Property (Puritan Influences)"></a>Property (Puritan Influences)</h4><p>An unalienable, God-given right</p><ul><li>We have the right to do what we will, as long as we remain within the bounds of the moral laws of nature</li><li>We are not permitted to give up our unalienable rights (e.g. commit suicide; sell ourselves into slavery), because we are properties of God before we are our own properties (vs. libertarian freedom)</li></ul><h5 id="Sanctity-of-labor-and-sanctity-of-property"><a href="#Sanctity-of-labor-and-sanctity-of-property" class="headerlink" title="Sanctity of labor and sanctity of property"></a>Sanctity of labor and sanctity of property</h5><ul><li><p>God entrusted the earth to Adam and all his descendants to share</p></li><li><p>Excess in wealth/wastefulness is a punishable crime against the laws of nature, which limits property rights to what a person can use</p></li><li><p>land is public property until it is enclosed for labor</p></li><li><p>one can purchase land with the fruits of one’s labor (food, goods, or money) </p></li><li><p>moderation in land enclosure allows for the co-existence of agricultural and nomadic cultures</p></li></ul><h4 id="Commonwealth"><a href="#Commonwealth" class="headerlink" title="Commonwealth"></a>Commonwealth</h4><ul><li>Civil society is created upon the consent of individual members to enter into a social contract (“compact”) for the sake of the protection of life, liberty, and property</li><li>legislative, judiciary, and law-enforcement powers entrusted to the government</li></ul><h4 id="Freedom-vs-license-cf-libertarianism"><a href="#Freedom-vs-license-cf-libertarianism" class="headerlink" title="Freedom vs. license (cf. libertarianism)"></a>Freedom vs. license (cf. libertarianism)</h4><p>We are not permitted to give up our unalienable rights (e.g. commit suicide; sell ourselves into slavery), because we are properties of God before we are our own properties</p><ol><li>legalization of “victimless crimes” (e.g. pornography, prostitution, recreational use of marijuana, assisted suicide, etc.)</li><li>lessez-faire capitalism</li></ol><h4 id="Revolution"><a href="#Revolution" class="headerlink" title="Revolution"></a>Revolution</h4><ul><li>The purpose of civil society: the protection of life, liberty, and property</li><li>When the government fails to carry out this purpose, or contradicts this purpose, it violates the terms of the social contract ——–&gt; the people have the right to overthrow such a government</li></ul><h2 id="George-Berkeley"><a href="#George-Berkeley" class="headerlink" title="George Berkeley"></a>George Berkeley</h2><h4 id="Empirical-idealism"><a href="#Empirical-idealism" class="headerlink" title="Empirical idealism:"></a>Empirical idealism:</h4><p><strong>“to be is to be perceived and to perceive”</strong></p><p>What we have immediate access to are in fact ideas of things formed in our minds (still in line with the Cartesian-Lockean theory of ideas)</p><ul><li><p>There are no material objects above or behind our ideas of things</p></li><li><p>“immaterialism” or “subjective idealism”: nothing exists apart from one’s mental perception</p></li><li><p>Experience of reality and Experience of illusion, whether ideas contradict each other</p></li></ul><h2 id="David-Hume"><a href="#David-Hume" class="headerlink" title="David Hume"></a>David Hume</h2><p>I cannot be sure if I really exist as a permanent subject of my experiences. All I have are impressions and ideas that come from experience.</p><h4 id="Rejection-of-causality"><a href="#Rejection-of-causality" class="headerlink" title="Rejection of causality"></a>Rejection of causality</h4><p>Our notions of “material” and “spiritual” (i.e., mental) “substances,” just like causality, are merely inventions of our psychological habits</p><h4 id="Denial-of-the-permanence-of-the-cognizant-self-as-a-substance"><a href="#Denial-of-the-permanence-of-the-cognizant-self-as-a-substance" class="headerlink" title="Denial of the permanence of the cognizant self as a substance"></a>Denial of the permanence of the cognizant self as a substance</h4><ul><li><p>Denied that there are spiritual (mental) substances underlying the subjects of perception</p></li><li><p>The mind is incapable of inventing ideas apart from experience</p></li></ul><h4 id="Denial-of-the-objectivity-of-beauty-as-a-substance"><a href="#Denial-of-the-objectivity-of-beauty-as-a-substance" class="headerlink" title="Denial of the objectivity of beauty as a substance"></a>Denial of the objectivity of beauty as a substance</h4><h2 id="Niccolò-Machiavelli"><a href="#Niccolò-Machiavelli" class="headerlink" title="Niccolò Machiavelli"></a>Niccolò Machiavelli</h2><h4 id="Negative-view-of-human-nature"><a href="#Negative-view-of-human-nature" class="headerlink" title="Negative view of human nature"></a>Negative view of human nature</h4><ul><li><p>Human beings are by nature selfish greedy, cowardly, dishonest, fickle, etc.</p></li><li><p> Effective government: control the people through fear, being loved by the people is good; being feared by the people is essential</p></li></ul><h4 id="Virtú-The-Ruler-as-Virtuoso"><a href="#Virtú-The-Ruler-as-Virtuoso" class="headerlink" title="Virtú: The Ruler as Virtuoso"></a>Virtú: The Ruler as Virtuoso</h4><ul><li>The centrality of virtú (prowess; power and skills)</li><li> A good ruler is not a moral example, but rather a virtuoso in the art of politics, the aim of which is to ensure the stability, security, and prosperity of a state</li><li>Virtú does not guarantee success: chance determines half of the outcomes of our lives, and success depends partly on luck</li><li>virtú allows the ruler to become opportunistic and take advantage of circumstances more effectively<br> Chance favors the macho man: the metaphor of rape</li></ul><h4 id="Cesare-Borgia-as-example"><a href="#Cesare-Borgia-as-example" class="headerlink" title="Cesare Borgia as example"></a>Cesare Borgia as example</h4><ul><li>Idolized by Hitler and Mussolini</li><li>Borgia’s murder of the Orsini family leaders in Sinigaglia</li><li>Borgia’s appoint of Romirro de Orco in Romagna, Orco’s body cut in half and displayed in the city square</li><li>Borgia did not practice cruelty for the sake of cruelty. He used cruelty skillfully to establish stability and prosperity (i.e., public interest) Borgia vs. Agathocles (4th-century tyrant of Syracuse, Sicily)</li></ul><h2 id="Thomas-Hobbes"><a href="#Thomas-Hobbes" class="headerlink" title="Thomas Hobbes"></a>Thomas Hobbes</h2><h4 id="Leviathan"><a href="#Leviathan" class="headerlink" title="Leviathan"></a>Leviathan</h4><p>A giant whose body consists of thousands of people, standing above an orderly city</p><ul><li>crown on the head, sword in one hand, scepter on another</li><li>looks down at the church spire</li><li>image of the Sovereign as representation and embodiment of the people</li><li>artificially created giant, a mortal god</li></ul><h4 id="Materialism"><a href="#Materialism" class="headerlink" title="Materialism"></a>Materialism</h4><h4 id="State-of-nature-1"><a href="#State-of-nature-1" class="headerlink" title="State of nature"></a>State of nature</h4><ul><li><p>All moral codes are conventional; they are not discovered, but rather created by the Sovereign, to whom the people have entrusted legislative power by social contract</p></li><li><p>still assumes the laws of nature, which are amoral</p></li><li><p>In a state of nature, there would be perpetual violence driven by instinctual greed, lust, desire to survive, etc.<br> No contract would be possible; no social power is there to ensure that promises are kept<br> “solitary, poor, nasty, brutish, and short”</p></li></ul><h4 id="Self-preservation-as-unalienable-right"><a href="#Self-preservation-as-unalienable-right" class="headerlink" title="Self-preservation as unalienable right"></a>Self-preservation as unalienable right</h4><p>The right to serf-preservation must be retained even in society under social contract, after other freedoms have been voluntarily given up</p><h4 id="The-Sovereign-定于一尊"><a href="#The-Sovereign-定于一尊" class="headerlink" title="The Sovereign (定于一尊)"></a>The Sovereign (定于一尊)</h4><ul><li><p>Leviathan is an image of the Sovereign —-&gt; can be a single person (e.g. monarch) or a group of people (e.g. parliament) by social contract</p></li><li><p>The sovereign state is formed by social contract upon the consent of free individuals</p></li><li><p>Entrusted with great power and force to administer the social contract</p></li><li><p> Power vested in the Sovereign by the people, not by God — &gt; right to the throne not sacrosanct</p></li><li><p>The natural right of self-preservation entitles individuals to resist persecution</p></li></ul><h4 id="Laws-of-Nature"><a href="#Laws-of-Nature" class="headerlink" title="Laws of Nature"></a>Laws of Nature</h4><p>Laws of Nature: laws that ensue from the use of reason (distinguished from Civil Law)</p><ul><li>all rational beings are bound by the Laws of Nature</li><li>Give up the rights and freedoms in the state of nature that are unsuitable under social contract, if you don’t want others to have these rights and freedoms against you</li></ul><h4 id="Use-of-Reason"><a href="#Use-of-Reason" class="headerlink" title="Use of Reason"></a>Use of Reason</h4><p>Laws of Nature: laws that ensue from the use of reason (distinguished from Civil Law)</p><h4 id="Freedom-vs-social-protection"><a href="#Freedom-vs-social-protection" class="headerlink" title="Freedom vs. social protection"></a>Freedom vs. social protection</h4><h2 id="Jean-Jacques-Rousseau"><a href="#Jean-Jacques-Rousseau" class="headerlink" title="Jean-Jacques Rousseau"></a>Jean-Jacques Rousseau</h2><h4 id="State-of-nature-An-enlightenment"><a href="#State-of-nature-An-enlightenment" class="headerlink" title="State of nature, An enlightenment"></a>State of nature, An enlightenment</h4><p>人性本善</p><ul><li>morality “uncorrupted” in the state of nature</li><li>the fruits of the earth belong to us all, and the earth itself to nobody” </li><li>egocentrism led to the formation of civil society</li></ul><h4 id="“Noble-savage”-an-erroneous-attribution-to-Rousseau"><a href="#“Noble-savage”-an-erroneous-attribution-to-Rousseau" class="headerlink" title="“Noble savage”, an erroneous attribution to Rousseau"></a>“Noble savage”, an erroneous attribution to Rousseau</h4><p>if enlightenment, civilization, and progress corrupt the original goodness of human nature, should we not return to the stage of the “noble savage”?</p><ul><li>This state is the veritable youth of the world; and that all the subsequent progress has been in appearance so many steps toward the perfection of the individual, and in fact toward the decay of the species.”</li></ul><h4 id="The-Social-Contract"><a href="#The-Social-Contract" class="headerlink" title="The Social Contract"></a>The Social Contract</h4><ul><li>A theoretical principle underlying the formation of human societies, especially the relations between the state and the citizens.</li><li>Basic incentive to enter into a social contract: the common good, creation of the state can provide protection of life and property in accordance with the general will of the people</li><li>To give up one’s natural freedom is to give up one’s humanity; A social contract that requires the abolition of freedom in exchange for protection is the very source of the social corruption of human nature</li></ul><h4 id="Civilization"><a href="#Civilization" class="headerlink" title="Civilization"></a>Civilization</h4><ul><li>Source of evil: egocentrism</li></ul><h5 id="Occasion-to-consult-reason-—-gt-nobility-of-human-nature"><a href="#Occasion-to-consult-reason-—-gt-nobility-of-human-nature" class="headerlink" title="Occasion to consult reason —-&gt; nobility of human nature"></a>Occasion to consult reason —-&gt; nobility of human nature</h5><ul><li>in the savage stage, people act by instinct; in civil society, people are forced to “consult reason before listening to his inclinations”</li><li>The nobility of humankind as a rational species shines forth only in civil society</li><li>Civilization can bring forth the nobility of human reason, if the decadence that it occasions is countered by the cultivation of moral virtue and duties</li><li>States and government would ennoble, rather than corrupt, human society, if we use moral reason to develop a social contract that reflects the inherent goodness of human nature</li></ul><h4 id="Freedom"><a href="#Freedom" class="headerlink" title="Freedom"></a>Freedom</h4><p>Civil Freedom—-&gt; the General Will</p><ul><li>Civil freedom: to act in accordance with the general will</li><li>this is something that we do not have in the savage stage</li><li>the exercise of civil freedom requires the use of reason</li><li>this is the noblest form of freedom</li><li>The achievement of civil freedom often requires coercive powers: the people must be “forced to be free”</li></ul><h4 id="Common-Good"><a href="#Common-Good" class="headerlink" title="Common Good"></a>Common Good</h4><p>The general will: the will of the state as a whole, aimed at the common good</p><h4 id="Democracy-cf-Rule-of-Law"><a href="#Democracy-cf-Rule-of-Law" class="headerlink" title="Democracy (cf. Rule of Law)"></a>Democracy (cf. Rule of Law)</h4><ul><li>Rousseau’s ideal state:<br> the general will = the Sovereign<br> (Democracy, in one modern sense of the term-– not the way Rousseau uses it!)</li><li>Rousseau: positive law (circumstantial &amp; conventional, serving the common good)</li><li>Rousseau on <strong>democracy</strong>:<ul><li>he means “direct democracy”</li><li>he does not favor democracy, because even though general vote usually reflects the general will (a problematic assumption), the logistics would be practically unmanageable </li></ul></li><li>Rousseau on monarchy:<br>The centralization of power in one individual is dangerous, especially in hereditary monarchies</li><li>Rousseau on aristocracy:<br>3 types: natural, elective, and hereditary <ul><li>Elective aristocracy is the best form of government, because it is the best representation of the general will in seeking the common good</li></ul></li><li></li></ul><h4 id="Cultivation"><a href="#Cultivation" class="headerlink" title="Cultivation"></a>Cultivation</h4><ul><li>Civilization can bring forth the nobility of human reason, if the decadence that it occasions is countered by the <strong>cultivation</strong> of moral virtue and duties</li><li>States and government would ennoble, rather than corrupt, human society, if we use moral reason to develop a social contract that reflects the inherent goodness of human nature</li></ul><h4 id="Private-ownership-as-civil-invention"><a href="#Private-ownership-as-civil-invention" class="headerlink" title="Private ownership as civil invention"></a>Private ownership as civil invention</h4><ul><li><p>“the fruits of the earth belong to us all, and the earth itself to nobody” </p></li><li><p>egocentrism led to the formation of civil society</p></li></ul><h4 id="Self-love-vs-pride"><a href="#Self-love-vs-pride" class="headerlink" title="Self-love vs. pride"></a>Self-love vs. pride</h4><p>self-love (self-preservation + reason) vs. pride (egocentrism)</p><h2 id="Samuel-Rutherford"><a href="#Samuel-Rutherford" class="headerlink" title="Samuel Rutherford"></a>Samuel Rutherford</h2><h4 id="Rule-of-Law"><a href="#Rule-of-Law" class="headerlink" title="Rule of Law"></a>Rule of Law</h4><p>(Different from rule by law)</p><ul><li>natural law vs. positive law<ul><li>The theory of natural law believes that our civil laws should be based on morality, ethics, and what is inherently correct. This is in contrast to what is called “positive law” or “man-made law,” which is defined by statute and common law and may or may not reflect the natural law. </li></ul></li><li>the law is the ruler of a state</li><li>the law is not a tool in the hands of the statesmen/stateswomen</li></ul><h4 id="Implications-of-the-rule-of-law"><a href="#Implications-of-the-rule-of-law" class="headerlink" title="Implications of the rule of law"></a>Implications of the rule of law</h4><ul><li>separation of powers </li><li>presumption of innocence </li><li>inalienable rights</li></ul><h4 id="Separation-of-powers"><a href="#Separation-of-powers" class="headerlink" title="Separation of powers"></a>Separation of powers</h4><p> The King is Beneath the Law</p><ul><li>Legitimacy of kingship is derived from the law, and not inherent</li><li>  The law defines the conditions for dethroning the king; the people have the right to dethrone the king in accordance with the law</li></ul><p><strong>Separation</strong> of Administrative and Legislative Powers</p><ul><li>Administrative branch of the government NOT the ‘fountain of laws’</li><li>Legislative power belongs to parliament;</li><li>Judicial Power</li></ul><h2 id="Immanuel-Kant"><a href="#Immanuel-Kant" class="headerlink" title="Immanuel Kant"></a>Immanuel Kant</h2><h4 id="Transcendental-idealism-empirical-realism-amp-formal-idealism"><a href="#Transcendental-idealism-empirical-realism-amp-formal-idealism" class="headerlink" title="Transcendental idealism: empirical realism &amp; formal idealism"></a>Transcendental idealism: empirical realism &amp; formal idealism</h4><ul><li>“Idealist”: “someone who only does not admit that it [the existence of external objects of sense] is cognized through immediate perception and infers form this that we can never be fully certain of their reality from any possible experience.”</li><li>“Transcendental”: the specific mode of cognition : “by means of which we cognize that and how certain representations… are applied entirely a priori (does not depend on sensory perception), or are possible.”</li><li>Transcendental idealism: “the doctrine that they [all appearances] are all together to be regarded as mere representations and not as things in themselves, and accordingly that space and time are only sensible forms of our intuition, but not determinations given for themselves or conditions of objects as things in themselves.”</li><li>Space and time are not real things in themselves, nor are they appearances of things that we intuit</li><li>Because our sensory perception can only cognize objects in space and time, this form of intuition—an active process on the part of the subject of cognition—is a necessary precondition for external things to actually appear to us.</li><li>We are not merely passive receivers of sensory data external to us. Our minds actually play an active organizing role in perceiving and understanding objects external to us.</li></ul><h4 id="Freedom-amp-Dignity"><a href="#Freedom-amp-Dignity" class="headerlink" title="Freedom &amp; Dignity"></a>Freedom &amp; Dignity</h4><p>Negative freedom = non-coerced will </p><p>positive freedom = autonomy</p><h5 id="“Autonomy-is-therefore-the-ground-of-the-dignity-of-human-nature”"><a href="#“Autonomy-is-therefore-the-ground-of-the-dignity-of-human-nature”" class="headerlink" title="“Autonomy is therefore the ground of the dignity of human nature”"></a>“Autonomy is therefore the ground of the dignity of human nature”</h5><h4 id="Humanity-is-evil-in-its-natural-propensity"><a href="#Humanity-is-evil-in-its-natural-propensity" class="headerlink" title="Humanity is evil in its natural propensity"></a>Humanity is evil in its natural propensity</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Branches-of-Philosophy&quot;&gt;&lt;a href=&quot;#Branches-of-Philosophy&quot; class=&quot;headerlink&quot; title=&quot;Branches of Philosophy&quot;&gt;&lt;/a&gt;&lt;strong&gt;Branches of </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TiFS: PingCAP Hackathon</title>
    <link href="https://anxue.xyz/blog/2021/TiFS-PingCAP-Hackathon/"/>
    <id>https://anxue.xyz/blog/2021/TiFS-PingCAP-Hackathon/</id>
    <published>2021-05-23T16:42:31.000Z</published>
    <updated>2021-08-12T12:07:01.282Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Hexilee/tifs">https://github.com/Hexilee/tifs</a></p><h2 id="TiFS-a-TiKV-Based-Partition-Tolerant-Strictly-Consistent-File-System"><a href="#TiFS-a-TiKV-Based-Partition-Tolerant-Strictly-Consistent-File-System" class="headerlink" title="TiFS, a TiKV-Based Partition Tolerant, Strictly Consistent File System"></a>TiFS, a TiKV-Based Partition Tolerant, Strictly Consistent File System</h2><p>Author: Hexi Lee (Software Engineer Intern at PingCAP)</p><p>Transcreator: Ran Huang; Editor: Tom Dewan</p><p>TiKV is a distributed key-value storage engine, featuring strong consistency and partition tolerance. It can act either as the storage engine for TiDB or as an independent transactional key-value database. Do you know what else it is capable of?</p><p>At TiDB Hackathon 2020, our team built a TiKV-based distributed POSIX file system, TiFS, which inherits the powerful features of TiKV and also taps into TiKV’s possibilities beyond data storage.</p><p>In this post, I’ll walk you through every detail of TiFS: how we came up with the idea, how we implemented the file system, and its benchmarking results. Let the hacking begin!</p><h3 id="Why-build-a-file-system-based-on-TiKV"><a href="#Why-build-a-file-system-based-on-TiKV" class="headerlink" title="Why build a file system based on TiKV?"></a>Why build a file system based on TiKV?</h3><p>A “distributed” system has multiple processes cooperating across machines; TiKV has that as well. Being a distributed database means it easily scales out and is fault tolerant by nature.</p><p>A friend of mine once wanted to try out TiDB but had only one server. I told him that he could run a TiKV instance on each disk, achieving data disaster tolerance, and wouldn’t need RAID anymore!</p><p>However, TiKV stores only data—not files—so you still need RAID to recover your files from a disaster. But it sparked an idea in me: if TiKV could store the file system data, then it could achieve disaster recovery for the file system. So we spent several days building TiFS. It was a POSIX file system and in the first version was bug-ridden and prone to deadlocks—but hey, the idea worked.</p><p>Why did we go to all this effort? Three reasons:</p><p>Unlike the common storage backend for distributed file systems, TiKV supports ACID-compliant distributed transactions. Therefore, we can guarantee strict consistency of the file system.<br>A POSIX file system not only covers the requirements of a local file system, but also supports file collaboration across machines and stores files for other distributed applications.<br>What’s even cooler, if we run a standalone application that supports multi-instance collaboration on TiFS, it becomes a distributed application.<br>Therefore, we started this project to build TiFS, a file system that is as strong as Titanium.</p><h3 id="How-we-implement-TiFS"><a href="#How-we-implement-TiFS" class="headerlink" title="How we implement TiFS"></a>How we implement TiFS</h3><p>TiKV only provides a simple key-value store, where keys and values are byte arrays with unfixed length. Therefore, before implementing the file system, we need to divide the logical area for keys and construct the data structure for values.</p><h4 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h4><p>TiFS stores seven types of values in TiKV: system metadata, file metadata, file block, file handler, symbolic link, directory, and file index. The file block is transparent data written by the user. The symbolic link only stores the target path. The other five values are structured data.</p><h4 id="System-metadata"><a href="#System-metadata" class="headerlink" title="System metadata"></a>System metadata</h4><p>The whole file system has only one system metadata (Meta), which is updated only during the mknod and mkdir operations. System metadata contains only one integer used to generate the file inode number:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meta</span></span> &#123;</span><br><span class="line">    inode_next: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="File-metadata"><a href="#File-metadata" class="headerlink" title="File metadata"></a>File metadata</h4><p>Each file has a corresponding file metadata (Inode). In this data structure:</p><p>file_attr stores the metadata required for a POSIX file system, such as the file inode number, the file size, and the number of blocks. See Rust File Attributes for details.<br>lock_state tracks the current lock state and the lock holder, which are used to implement flock.<br>inline_data stores a small amount of file content to improve the read/write performance of tiny files.<br>next_fn is an auto-increment integer used to generate the file handler.<br>opened_fn records the number of opened file handlers.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inode</span></span> &#123;</span><br><span class="line">    file_attr: FileAttr,</span><br><span class="line">    lock_state: LockState,</span><br><span class="line">    inline_data: <span class="built_in">Option</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt;,</span><br><span class="line">    next_fh: <span class="built_in">u64</span>,</span><br><span class="line">    opened_fh: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="File-handler"><a href="#File-handler" class="headerlink" title="File handler"></a>File handler</h4><p>Every time the user calls open, the file system generates a corresponding file handler (FileHandler) to store the read/write limits of the handler:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileHandler</span></span> &#123;</span><br><span class="line">    flags: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h4><p>Each directory stores a list of subfiles so that it can implement readdir. In the list, each DirItem item stores the inode number, name, and type of file:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Directory</span></span> = <span class="built_in">Vec</span>&lt;DirItem&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DirItem</span></span> &#123;</span><br><span class="line">    ino: <span class="built_in">u64</span>,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    typ: FileType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="File-index"><a href="#File-index" class="headerlink" title="File index"></a>File index</h4><p>When we query a file, the file system can traverse the whole file directory; but to query files more efficiently, we create an index (Index) for each file. The file index only contains the inode number of the target file:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Index</span></span> &#123;</span><br><span class="line">    ino: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h4><p>TiFS has five types of keys: system metadata, file metadata, file block, file handler, and file index. Among them, the file block key stores the file block data, symbolic link, and directory, while the other four keys store their corresponding values.</p><p>The first byte of the block, also known as the scope, identifies the type of key. The key’s byte arrays usually follows this pattern:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="number">1</span> byte +&lt;--------------------------------+ dynamic size +---------------------------------------&gt;+</span><br><span class="line">|        |                                                                                         |</span><br><span class="line">+--------------------------------------------------------------------------------------------------+</span><br><span class="line">|  scope |                                         key                                             |</span><br><span class="line">+--------+-----------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>The system metadata scope has only one key-value pair:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="number">1</span> byte +</span><br><span class="line">|        |</span><br><span class="line">|        |</span><br><span class="line">|        |</span><br><span class="line">|        |</span><br><span class="line">|        |</span><br><span class="line">|        |</span><br><span class="line">|        v</span><br><span class="line">+--------+</span><br><span class="line">|        |</span><br><span class="line">|    <span class="number">0</span>   |</span><br><span class="line">|        |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure><p>The file metadata key only contains the inode number in big-endian ordering so that all the file metadata are sequentially stored in TiKV. Thus, for the statfs operation, we can get all the file metadata using TiKV’s scan interface.</p><p>The file metadata key is as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="number">1</span> byte +&lt;----------------------------------+ <span class="number">8</span> bytes +------------------------------------------&gt;+</span><br><span class="line">|        |                                                                                         |</span><br><span class="line">|        |                                                                                         |</span><br><span class="line">|        |                                                                                         |</span><br><span class="line">|        |                                                                                         |</span><br><span class="line">|        |                                                                                         |</span><br><span class="line">|        |                                                                                         |</span><br><span class="line">|        v                                                                                         v</span><br><span class="line">+--------------------------------------------------------------------------------------------------+</span><br><span class="line">|        |                                                                                         |</span><br><span class="line">|    <span class="number">1</span>   |                                     inode number                                        |</span><br><span class="line">|        |                                                                                         |</span><br><span class="line">+--------+-----------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>The file block key is composed of the file inode number and the block index in big-endian ordering. All file blocks for a single file are sequentially stored in TiKV. When we need to read large chunks of data, we can get the desired file blocks by one scan.</p><p>The key’s array is listed below:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 1 byte +<span class="variable">&lt;---------------- 8 bytes ---------------&gt;</span>+<span class="variable">&lt;------------------ 8 bytes -----------------&gt;</span>+</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        v                                          v                                              v</span></span><br><span class="line"><span class="string">+--------------------------------------------------------------------------------------------------+</span></span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">    2   </span>|<span class="string">              inode number                </span>|<span class="string">                   block index                </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">+--------+------------------------------------------+----------------------------------------------+</span><br></pre></td></tr></table></figure><p>The file handler key consists of the file inode number and the file handler number in big-endian ordering:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 1 byte +<span class="variable">&lt;---------------- 8 bytes ---------------&gt;</span>+<span class="variable">&lt;------------------ 8 bytes -----------------&gt;</span>+</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        v                                          v                                              v</span></span><br><span class="line"><span class="string">+--------------------------------------------------------------------------------------------------+</span></span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">    3   </span>|<span class="string">              inode number                </span>|<span class="string">                  file handler                </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">+--------+------------------------------------------+----------------------------------------------+</span><br></pre></td></tr></table></figure><p>The file index key includes the inode number of its parent directory in big-endian ordering and the file name in UTF-8 encoding:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 1 byte +<span class="variable">&lt;---------------- 8 bytes ---------------&gt;</span>+<span class="variable">&lt;------------------ 8 bytes -----------------&gt;</span>+</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">        v                                          v                                              v</span></span><br><span class="line"><span class="string">+--------------------------------------------------------------------------------------------------+</span></span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">|<span class="string">    4   </span>|<span class="string">     inode number of parent directory     </span>|<span class="string">         file name in utf-8 encoding          </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                                          </span>|<span class="string">                                              </span>|</span><br><span class="line">+--------+------------------------------------------+----------------------------------------------+</span><br></pre></td></tr></table></figure><h4 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h4><p>TiKV supports both optimistic and pessimistic transactions. However, since the Rust client only supports pessimistic transactions experimentally, and pessimistic transactions may reduce performance when transactions don’t conflict, we implement TiFS by optimistic transactions only.</p><h4 id="Various-scenarios"><a href="#Various-scenarios" class="headerlink" title="Various scenarios"></a>Various scenarios</h4><p>TiFS is most efficient for reading and writing small files or other complicated file system operations. Although TiFS can handle large files, compared to other large file storage solutions it is not as powerful or efficient.</p><p>Here are a few uses of TiFS that you may find interesting:</p><p>A Git remote repository can directly use TiFS to store the project and run Git tasks, such as rebase or cherry-pick, without transferring the files to the local file system.<br>When multiple nodes of an application read or write the same file in TiFS, you can use flock to resolve any conflicts.<br>There’s no complicated SDK or API for space management. You simply call the file system API or run a shell script.<br>TiFS lets you take a standalone application that supports multi-instance collaboration and turn it into a distributed application. For example, SQLite + TiFS = yet another distributed relational database. Admittedly, to use TiFS this way, the application cannot rely on page cache or other caching mechanisms to avoid writes being invisible.</p><p><img src="/blog/2021/05/24/TiFS-PingCAP-Hackathon/tifs-makes-sqlite-another-distributed-relational-database.gif"></p><h3 id="Tests-and-benchmarks"><a href="#Tests-and-benchmarks" class="headerlink" title="Tests and benchmarks"></a>Tests and benchmarks</h3><p>During the Hackathon, we used pjdfstest to test TiFS’s correctness. But because pjdfstest doesn’t cover read/write correctness or concurrency correctness, we will need to add other tests.</p><p>Theoretically, there are three major factors that influence the read/write performance of TiFS: the size of file system blocks, the network latency, and the size of load blocks. Here we’ll show the benchmarking results of the read/write IOPS and speed.</p><h4 id="IOPS"><a href="#IOPS" class="headerlink" title="IOPS"></a>IOPS</h4><p>Note: TiKV is a sophisticated system, in which there are logical duration, disk I/O duration, and network duration. In this article, we simplify TiKV to a single replica for demonstration purposes.</p><p>Let’s first take a look at IOPS. Because sequential reads and writes perform I/O operations linearly, each I/O operation is a transaction in TiKV. If we ignore the minor differences between each operation, the duration of an I/O operation, T, is the reciprocal of IOPS. In addition, if we don’t count stream processing, we can consider T as the linear addition of the following four variables:</p><p>Tf: the I/O duration of FUSE.<br>Tc: the logical duration of TiFS.<br>Tn: the network transmission time.<br>Ts: the logical duration of TiKV.<br>Accordingly, we have this equation:</p><h5 id="Read-IOPS"><a href="#Read-IOPS" class="headerlink" title="Read IOPS"></a>Read IOPS</h5><p>For read operations, Tf is positively correlated to the size of load blocks. The size of data read or written by TiFS per I/O operation must be an integer multiple of the size of file system blocks. Therefore, Tn and Ts are positively correlated to the larger value between load blocks and file system blocks; however, with larger traffic, network and disk I/O may take longer. Tc is unknown.</p><p>The following diagram shows how the sequential read IOPS varies with the size of load blocks. The four lines represent different filesystem block sizes and data replicas.</p><h6 id="Read-IOPS-benchmarking-results"><a href="#Read-IOPS-benchmarking-results" class="headerlink" title="Read IOPS benchmarking results"></a>Read IOPS benchmarking results</h6><p>Before the benchmarking, we had the following projections:</p><p>When both the file block and load block are 4 KB, if the load block increases, Tf, Tn, and Ts increase; therefore, IOPS decreases.<br>When the file block is 64 KB or 1 MB:<br>If the load block is smaller than the file block, Tn and Ts barely change, but Tf increases; therefore, IOPS decreases.<br>If the load block is larger than the file block, Tf, Tn, and Ts all increase; therefore, IOPS decreases.<br>As you can see in the diagram, the variation is almost identical to our projections.</p><h5 id="Write-IOPS"><a href="#Write-IOPS" class="headerlink" title="Write IOPS"></a>Write IOPS</h5><p>When TiFS sequentially writes data, if the load block is smaller than the file block, TiFS needs to read a dirty block, which causes extra Tc and Tn. When the file block is large, that extra overhead is noticeable.</p><p>The following line chart shows how the sequential write IOPS varies with the size of the load blocks. When the file blocks are 1 MB (see the yellow line), the IOPS is largest while the file block and load block are equivalent.</p><h6 id="Write-IOPS-benchmarking-results"><a href="#Write-IOPS-benchmarking-results" class="headerlink" title="Write IOPS benchmarking results"></a>Write IOPS benchmarking results</h6><p>Moreover, we can see that the red line almost overlaps the blue line on the first two data points. This means when the load block and file block are 4 KB or 64 KB, their IOPS values are nearly the same. Under such circumstances, the minimum traffic per second is 4 KB 110 = 440 KB, and the maximum is 64 KB 100 = 6.25 MB, both putting little pressure on the network and disks. When the traffic is small enough, it is safe to say that IOPS reaches its upper limit, so the major factor of Tn becomes network latency. (In local testing, Tn is considered 0 ms.)</p><p>In the chart above, when file blocks and load blocks change between 4 KB and 64 KB, IOPS is almost unaffected. Under such configurations, T is determined by Tc and Ts, so we call it the fixed system operation latency of TiFS. The fixed system operation latency is caused by TiFS and TiKV’s logical duration. If the latency is high enough, it leads to terrible read/write performance for small files. We are still working on this optimization.</p><h4 id="Speed"><a href="#Speed" class="headerlink" title="Speed"></a>Speed</h4><p>Because the read and write speeds are the product of IOPS multiplied by load blocks, and IOPS changes very little when the load block increases from 4 KB to 1 MB, read and write speeds reach the maximum value when the load block is 1 MB.</p><p>The following two bar charts compare the read and write speeds in different cluster configurations when the load block is 1 MB. The blue bar represents ordinary TiKV, while the red bar represents TiKV with Titan enabled.</p><p>Titan is a RocksDB Plugin for key-value separation, inspired by WiscKey, to reduce write amplification.</p><p>From the charts, we can see that the write speed is mostly affected by the file block size and whether Titan is enabled, and that the read speed is only slightly fluctuating. This is because the smaller the file block is, the more key-value pairs TiKV writes into, which takes more time. But RocksDB performs poorly with large file blocks, so enabling Titan can reduce unnecessary value copy and thus improve performance.</p><h4 id="Our-next-step"><a href="#Our-next-step" class="headerlink" title="Our next step"></a>Our next step</h4><p>In TiFS, storing file blocks is very costly because TiKV implements redundancy by using multiple replicas (three by default). The redundancy ratio (occupied space divided by written data volume) is usually three or more.</p><p>However, the redundancy ratio is as low as 1.2~1.5 in other distributed file systems that support redundancy by erasure coding (EC), such as HDFS, CephFS, and JuiceFS. EC redundancy requires encoding and decoding during data write and reconstruction, which consumes extra computing resources. However, the EC redundancy strategy sacrifices part of the read performance in exchange for lower network overhead and storage cost.</p><p>Currently, it is somewhat difficult for TiKV to support EC, but we plan to support EC-redundancy object storage for file blocks to reduce storage cost.</p><p>Apart from that, we’ll focus on verifying correctness and tuning performance:</p><p>For correctness, we’ll research how other file systems are tested and use that knowledge to build our own tests.<br>For performance, we’ll cover both TiFS and TiKV to reduce the innate latency.<br>If you are interested in TiFS, feel free to try it out or join our discussion!</p><p>At TiDB Hackathon 2020, many excellent, interesting projects were born. We’ll be telling you about them in future blog posts. Stay tuned.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/Hexilee/tifs&quot;&gt;https://github.com/Hexilee/tifs&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;TiFS-a-TiKV-Based-Partition-Tolerant-Strictly-C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>My OS</title>
    <link href="https://anxue.xyz/blog/2021/My-OS-my-choice/"/>
    <id>https://anxue.xyz/blog/2021/My-OS-my-choice/</id>
    <published>2021-05-19T16:58:55.000Z</published>
    <updated>2021-08-12T12:07:21.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NH3OS"><a href="#NH3OS" class="headerlink" title="NH3OS"></a>NH3OS</h1><p><strong>FIRST PLACE</strong> in Microsoft Sponsored Kernel Design Competition.</p><p><strong>HAPPY GRADUATION!</strong></p><h2 id="Baseline-Functionality"><a href="#Baseline-Functionality" class="headerlink" title="Baseline Functionality"></a>Baseline Functionality</h2><ul><li>PS/2 keyboard driver</li><li>i8259 driver</li><li>pit and rtc driver</li><li>GDT/IDT</li><li>Basic Exception/Trap Handlers</li><li>Paging</li><li>VGA Text-mode terminal</li><li>Initrd Read-only Filesystem (fake)</li><li>System Calls (read, write, videomap…)</li><li>Process Control Block</li><li>User level code loader and user/kernel stack switching</li><li>Round-robin scheduling</li><li>Heap (fake)</li></ul><h2 id="Extra-Functionality"><a href="#Extra-Functionality" class="headerlink" title="Extra Functionality"></a>Extra Functionality</h2><h3 id="Extra-Device-Drivers"><a href="#Extra-Device-Drivers" class="headerlink" title="Extra Device Drivers"></a>Extra Device Drivers</h3><ul><li>PS/2 Mouse Driver</li><li>PCI Driver</li><li>RTL8139 Driver</li></ul><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><ul><li>Cascading windows</li><li>VESA high resolution display</li><li>Windows drag and drop using mouse</li><li>Basic responsive support (open close)</li></ul><h3 id="Networking-Stack"><a href="#Networking-Stack" class="headerlink" title="Networking Stack"></a>Networking Stack</h3><ul><li>NIC: RTL8139 Driver, ring buffer</li><li>Link Layer: Ethernet II support</li><li>Network Layer: ARP</li><li>Network Layer:  IPv4</li><li>Transport Layer: UDP</li><li>Transport Layer: TCP (Buggy)</li><li>Application Layer: DNS</li></ul><h3 id="Some-Networking-Explanation"><a href="#Some-Networking-Explanation" class="headerlink" title="Some Networking Explanation"></a>Some Networking Explanation</h3><p><img src="/blog/2021/05/20/My-OS-my-choice/Slirp_concept.png"></p><ul><li><p>Qemu has a whole user mode network stack, it can redirect TCP and UDP protocols from qemu user to host.</p></li><li><p>Thus our OS’s NIC has IP address 10.0.2.15</p></li><li><p>We send ARP requests to get the mac address of gateway (10.0.2.2), this is placed in any IPv4 packet leaving our OS</p></li><li><p>DNS requests to 10.0.2.3:53, just send UDP requests and parse responses </p></li><li><p>Note that from inside the guest, connecting to a port on the “gateway” 10.0.2.2 will connect to that port on the host</p></li><li><p>To connect Host to Guest use TCP hostfwd when launching Qemu</p></li><li><p>Debugging:  use Wireshark and object dump to analyze packets</p></li></ul><h3 id="Bug-List"><a href="#Bug-List" class="headerlink" title="Bug List"></a>Bug List</h3><ul><li><input disabled="" type="checkbox"> GUI stability</li><li><input disabled="" type="checkbox"> GUI when booting eats up CPU, need GPU accelaration</li><li><input disabled="" type="checkbox"> TCP losing packets, “egress” unstable, no congestion control, no real sockets</li><li><input disabled="" type="checkbox"> Heap memory allocation bugs</li><li><input disabled="" type="checkbox"> Stability in whole, randomly crashes</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NH3OS&quot;&gt;&lt;a href=&quot;#NH3OS&quot; class=&quot;headerlink&quot; title=&quot;NH3OS&quot;&gt;&lt;/a&gt;NH3OS&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;FIRST PLACE&lt;/strong&gt; in Microsoft Sponsored Kernel</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Jump Table to Superb Blog Posts</title>
    <link href="https://anxue.xyz/blog/2021/JumpTable/"/>
    <id>https://anxue.xyz/blog/2021/JumpTable/</id>
    <published>2021-04-14T17:13:28.000Z</published>
    <updated>2021-04-14T17:52:58.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p><a href="http://lwn.net/Articles/250967/">http://lwn.net/Articles/250967/</a></p><p><a href="https://searchstorage.techtarget.com/definition/NVRAM-non-volatile-random-access-memory">https://searchstorage.techtarget.com/definition/NVRAM-non-volatile-random-access-memory</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Memory&quot;&gt;&lt;a href=&quot;#Memory&quot; class=&quot;headerlink&quot; title=&quot;Memory&quot;&gt;&lt;/a&gt;Memory&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://lwn.net/Articles/250967/&quot;&gt;http://lwn.n</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>WAFL &amp; Shadow Paging</title>
    <link href="https://anxue.xyz/blog/2021/WAFL/"/>
    <id>https://anxue.xyz/blog/2021/WAFL/</id>
    <published>2021-04-14T14:02:07.000Z</published>
    <updated>2021-04-14T18:01:52.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shadow-Paging"><a href="#Shadow-Paging" class="headerlink" title="Shadow Paging"></a>Shadow Paging</h2><p>Shadow paging is a copy-on-write technique for avoiding in-place updates of pages. Instead, when a page is to be modified, a shadow page is allocated. When the page is ready to become durable, all pages that referred to the original are updated to refer to the new replacement page instead. Because the page is “activated” only when it is ready, it is atomic.</p><h2 id="Read-Through-Write-Through-Write-Behind-Caching-and-Refresh-Ahead"><a href="#Read-Through-Write-Through-Write-Behind-Caching-and-Refresh-Ahead" class="headerlink" title="Read-Through, Write-Through, Write-Behind Caching and Refresh-Ahead"></a>Read-Through, Write-Through, Write-Behind Caching and Refresh-Ahead</h2><p>WAFL uses write-behind caching, NVRAM as a cache of unwritten disk blocks.  This means <strong>cache</strong> layer itself connects to the backing database. This means that your applications need only ever connect to your <strong>cache</strong> layer.</p><p><a href="https://docs.oracle.com/cd/E13924_01/coh.340/e13819/readthrough.htm">https://docs.oracle.com/cd/E13924_01/coh.340/e13819/readthrough.htm</a></p><p>WAFL gathers up many hundreds of NFS requests before scheduling a write episode. During a write episode, WAFL allocates disk space for all the dirty data in the cache and schedules the required disk I/O. </p><h2 id="Same-as-EXT2-except-Snapshots"><a href="#Same-as-EXT2-except-Snapshots" class="headerlink" title="Same as EXT2 except Snapshots"></a>Same as EXT2 except Snapshots</h2><p>Metadata:</p><ul><li>inode file</li><li>block-map file (free blocks)</li><li> inode-map (free inodes)</li></ul><p>Keeping meta-data in files makes it easy to increase the size of the file system on the fly. </p><p>4 KB blocks. Each WAFL inode contains 16 block pointers to indicate which blocks belong to the file. Inodes for larger files point to doubly indirect blocks. For very small files, data is stored in the inode itself in place of the block pointers.</p><p>The write-anywhere design good for distributing writes evenly across RAID.</p><h2 id="Snapshots"><a href="#Snapshots" class="headerlink" title="Snapshots"></a>Snapshots</h2><p>WAFL simply duplicates the root inode. Makes snapshot at consistency point every 10 seconds.</p><p>WAFL uses non-volatile RAM (NVRAM) to keep a log of NFS requests it has processed since the last consistency point. After an unclean shutdown, WAFL replays any requests in the log to prevent them from being lost. </p><ul><li>WAFL can write any file system block (except the one containing the root inode) to any location on disk. </li><li>WAFL can write blocks to disk in any order.</li><li>WAFL can allocate disk space for many NFS operations at once in a single write episode.</li></ul><p>WAFL’s technique for keeping Snapshot data self consistent is to mark all the dirty data in the cache as “IN_SNAPSHOT.” The rule during Snapshot creation is that data marked IN_SNAPSHOT must not be modified, and data not marked IN_SNAPSHOT must not be flushed to disk. WAFL must flush IN_SNAPSHOT data as quickly as possible. </p><ul><li>Allocate disk space for all files with IN_SNAPSHOT blocks. WAFL caches inode data in two places: in a special cache of in-core inodes, and in disk buffers belonging to the inode file.  WAFL copies the newly updated inode information from the inode cache into the appropriate inode file disk buffer, and clears the IN_SNAPSHOT bit on the in-core inode. <strong>No disk access.</strong> <strong>Quick.</strong></li><li>Update the block-map file. </li><li>Flush IN_SNAPSHOT disk buffers to disk, can start NFS requests.</li><li>Duplicate the root inode, turn the root inode’s IN_SNAPSHOT bit off.  Reach the disk last.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shadow-Paging&quot;&gt;&lt;a href=&quot;#Shadow-Paging&quot; class=&quot;headerlink&quot; title=&quot;Shadow Paging&quot;&gt;&lt;/a&gt;Shadow Paging&lt;/h2&gt;&lt;p&gt;Shadow paging is a copy-on</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ARIES</title>
    <link href="https://anxue.xyz/blog/2021/ARIES/"/>
    <id>https://anxue.xyz/blog/2021/ARIES/</id>
    <published>2021-04-14T11:13:20.000Z</published>
    <updated>2021-04-14T20:25:37.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stealing-and-Forcing"><a href="#Stealing-and-Forcing" class="headerlink" title="Stealing and Forcing"></a>Stealing and Forcing</h2><p>Stealing happens when buffer pool is full, pages modified by uncommitted transactions can get kicked into stable storage.</p><p>Forcing means that every time a transaction commits, all the affected pages will be pushed to stable storage.</p><p>STEAL or NO-STEAL – Can an update made by an uncommitted transaction overwrite the most recent committed value of a data item on disk?</p><p>FORCE or NO-FORCE – Should all updates of a transaction be forced to disk before the transaction commits?</p><ul><li>Easiest for recovery: NO-STEAL/FORCE</li><li>Highest performance: STEAL/NO-FORCE</li><li>Undo logging: Steal/Force<ul><li>uncommmited writes?</li><li>output early</li></ul></li><li>Redo logging: No-Steal/No-Force<ul><li>commited stuff not written</li><li>output late</li></ul></li></ul><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>The recovery works in three phases.</p><ul><li>The first phase, <strong>Analysis</strong>, computes all the necessary information from the logfile.  Rebuild active transactions table and dirty pages table.</li><li><strong>Redo</strong> some transaction that did commit. Replay history, starting from first recLSN, page granularity. The <strong>Redo</strong> phase restores the database to the exact state at the crash, including all the changes of uncommitted transactions that were running at that point in time.</li><li><strong>Undo</strong> other transactions that didn’t commit. The <strong>Undo</strong> phase then undoes all uncommitted changes, leaving the database in a consistent state. Only affects log entries. Write to log as CLR (Compensating log records), redone never undone.</li></ul><h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>All log records pertaining to a page are written to disk before the page is overwritten on disk.</p><p>All log records for transaction are written to disk before the transaction is considered committed.</p><h2 id="Granularity"><a href="#Granularity" class="headerlink" title="Granularity"></a>Granularity</h2><ul><li>Page-oriented logging for REDO (element=one page)</li><li>Logical logging for UNDO (element=one record)</li></ul><p>Actual logs logical operations within a page.</p><h2 id="Checkpoints"><a href="#Checkpoints" class="headerlink" title="Checkpoints"></a>Checkpoints</h2><p>Write into the log</p><p>–  Entire active transactions table</p><p> –  Entire dirty page table</p><h2 id="ARIES-Data-Structures"><a href="#ARIES-Data-Structures" class="headerlink" title="ARIES Data Structures"></a>ARIES Data Structures</h2><ul><li>Active Transactions Table, &lt;trans_id, lastLSN&gt;</li><li>Dirty Page Table, &lt;page_id, recLSN&gt;</li><li>Write Ahead Log, &lt;LSN, prevLSN, trnas_id, page_id, log_entry&gt;</li><li>Buffer pool = table of  pairs  &lt;PageLSN, page_id&gt;</li></ul><p>LSN= log sequence number, LSN’s help us find the end of a circular log file.</p><p>lastLSN = most recent update by transaction</p><p>recoveryLSN (recLSN)= first LSN that caused page to become dirty</p><p>prevLSN = previous LSN for same transaction</p><h2 id="Aries-Steps"><a href="#Aries-Steps" class="headerlink" title="Aries Steps"></a>Aries Steps</h2><ul><li>Add log record</li><li>Update transactions table</li><li>Update dirty page table</li><li>Update pageLSN</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Stealing-and-Forcing&quot;&gt;&lt;a href=&quot;#Stealing-and-Forcing&quot; class=&quot;headerlink&quot; title=&quot;Stealing and Forcing&quot;&gt;&lt;/a&gt;Stealing and Forcing&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CUDA ECE 408</title>
    <link href="https://anxue.xyz/blog/2020/CUDA/"/>
    <id>https://anxue.xyz/blog/2020/CUDA/</id>
    <published>2020-11-14T16:53:19.000Z</published>
    <updated>2021-04-14T17:03:01.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sparse-Matrix-Vector-Multiplication"><a href="#Sparse-Matrix-Vector-Multiplication" class="headerlink" title="Sparse Matrix-Vector Multiplication"></a>Sparse Matrix-Vector Multiplication</h2><p><strong>M rows, N columns, K non-zeros, L non-zero elements in the row with the largest number of non-zeros.</strong></p><p>COO: 3K</p><p>CSR: 2K + M + 1</p><p>ELL: 2M*L</p><p>JDS: 2K+2M</p><p>JDS-T: 2K + 2M + L</p><p>Aligned accesses need to start at a 16-word boundary and threads in a warp need to access continuous locations. Non-aligned need not start at a 16-word boundary. Whereas coalesced just means that threads in a warp need to access continuous locations. Transposition helps reduce non-coalesced accesses.</p><p><strong>ELL</strong> best for control divergence.</p><p><strong>ELL</strong> and <strong>JDS-T</strong> coalesced</p><p><img src="/2020/11/15/CUDA/image-20201209004919794.png" alt="image-20201209004919794"></p><p><img src="/2020/11/15/CUDA/image-20201209004948402.png" alt="image-20201209004948402"></p><p><img src="/2020/11/15/CUDA/image-20201209005013410.png" alt="image-20201209005013410"></p><p><img src="/2020/11/15/CUDA/image-20201209005036563.png" alt="image-20201209005036563"></p><h2 id="Kogge-Stone-scan-kernel"><a href="#Kogge-Stone-scan-kernel" class="headerlink" title="Kogge-Stone scan kernel"></a>Kogge-Stone scan kernel</h2><p>Total # of add operations: n * log(n) - (n-1)</p><h3 id="Control-Divergence"><a href="#Control-Divergence" class="headerlink" title="Control Divergence"></a>Control Divergence</h3><p>1024 elements  where stride is 16: 1 warp</p><p>1024 elements  where stride is 64: 0 warp</p><h2 id="Brent-Kung-Scan-kernel"><a href="#Brent-Kung-Scan-kernel" class="headerlink" title="Brent-Kung Scan kernel"></a>Brent-Kung Scan kernel</h2><p>Total # of add operations:  2*(n-1) – log(n)</p><h2 id="Privatisation-and-Histogramming"><a href="#Privatisation-and-Histogramming" class="headerlink" title="Privatisation and Histogramming"></a>Privatisation and Histogramming</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">histo_kernel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">long</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> *histo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> __shared__ <span class="keyword">unsigned</span> <span class="keyword">int</span> histo_private[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = threadIdx.x; i &lt; <span class="number">1024</span>; i+=blockDim.x) histo_privat[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> __syncthreads();</span><br><span class="line"> <span class="keyword">int</span> i = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stride is total number of threads </span></span><br><span class="line"><span class="keyword">int</span> stride = blockDim.x * gridDim.x</span><br><span class="line"><span class="keyword">while</span> (i &lt; size) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( buffer[i]... ) atomicAdd( &amp;(private_histo[buffer[i]), <span class="number">1</span>); </span><br><span class="line">  <span class="keyword">else</span> atomicAdd( &amp;(histo[buffer[i]), <span class="number">1</span> );</span><br><span class="line">  i += stride; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="number">2048</span>; i += <span class="number">1</span>)</span><br><span class="line">    atomicAdd( &amp;(histo[buffer[i]),  private_histo[buffer[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Theoretical-minimum-runtime-of-the-original-histogram-kernel"><a href="#Theoretical-minimum-runtime-of-the-original-histogram-kernel" class="headerlink" title="Theoretical minimum runtime of the original histogram kernel"></a>Theoretical minimum runtime of the <strong>original histogram kernel</strong></h4><ol><li><p>(blockDim*loop_num) *largest_percentage * 1 ns + gridDim * 100 ns</p><p>Loop_num is also number of elements per thread.</p></li></ol><p><img src="/2020/11/15/CUDA/image-20201208224920842.png" alt="image-20201208224920842"></p><p>10**7 + 5000</p><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><p>dim3 outputDim(W_out, H_out, 1);</p><p>dim3 inputDim(W, H, 1);</p><ol><li>OutputDim maps to the output so it will use fewer threads, this also has less control divergence if using shared memory and strategy 2. inputDim maps to the input so it can load the shared memory in a single pass.</li></ol><h2 id="Convolution-calculation"><a href="#Convolution-calculation" class="headerlink" title="Convolution calculation"></a>Convolution calculation</h2><p>For input elements</p><p>– Each output tile has TILE_WIDTH^2 elements<br> – Each input tile has (TILE_WIDTH+K-1)^2<br> – The total number of input feature map element accesses was TILE_WIDTH^2 * K^2<br> – The reduction factor of the tiled algorithm is K^2 * TILE_WIDTH^2 / (TILE_WIDTH+K-1)^2</p><h2 id="Unroll"><a href="#Unroll" class="headerlink" title="Unroll"></a>Unroll</h2><p><img src="/2020/11/15/CUDA/image-20201209094952824.png" alt="image-20201209094952824"></p><p><img src="/2020/11/15/CUDA/image-20201209095014432.png" alt="image-20201209095014432"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Sparse-Matrix-Vector-Multiplication&quot;&gt;&lt;a href=&quot;#Sparse-Matrix-Vector-Multiplication&quot; class=&quot;headerlink&quot; title=&quot;Sparse Matrix-Vector M</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>EPOLL</title>
    <link href="https://anxue.xyz/blog/2020/EPOLL/"/>
    <id>https://anxue.xyz/blog/2020/EPOLL/</id>
    <published>2020-07-06T11:13:27.000Z</published>
    <updated>2021-04-14T11:14:34.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p>We start with epoll_create. <code>epoll_create</code> can have an input flag EPOLL_CLOEXEC. O_CLOEXEC means close on <code>execve()</code>.</p><p>O_CLOEXEC avoids race conditions where one thread opens a file descriptor at the same time as another thread does a <code>fork() + execve()</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create1, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> do_epoll_create(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So <code>epoll_create</code>tells us to look at <code>do_epoll_create</code>.</p><p>Must clarify some ambiguous abbreviated variable names before code:</p><ul><li>The fds epoll registers in the VFS are called <code>epfd</code></li><li><code>struct eventpoll</code> has variable name <code>ep</code></li><li><code>epi</code> has variable name of <code>epitem</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_epoll_create</span><span class="params">(<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> error, fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* Check the EPOLL_* constant for consistency.  */</span></span><br><span class="line">  BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Create the internal data structure (&quot;struct eventpoll&quot;).</span></span><br><span class="line"><span class="comment">   * ep_alloc uses kzalloc, slab cache quickens memory use.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  error = ep_alloc(&amp;ep);</span><br><span class="line">  <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Creates all the items needed to setup an eventpoll file. </span></span><br><span class="line"><span class="comment">   * Get an unused file descriptor and an anonymous inode file, use fd_install to bind them.</span></span><br><span class="line"><span class="comment">   * Set file operations: poll, release, llseek. </span></span><br><span class="line"><span class="comment">   * release closes file and llseek repositions the offset of the open file descriptor.</span></span><br><span class="line"><span class="comment">   * See eventpoll_fops below.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC)</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    error = fd;</span><br><span class="line">    <span class="keyword">goto</span> out_free_ep;</span><br><span class="line">  &#125;</span><br><span class="line">  file = anon_inode_getfile(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">         O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">    error = PTR_ERR(file);</span><br><span class="line">    <span class="keyword">goto</span> out_free_fd;</span><br><span class="line">  &#125;</span><br><span class="line">  ep-&gt;file = file;</span><br><span class="line">  fd_install(fd, file);</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">​</span><br><span class="line">out_free_fd:</span><br><span class="line">  put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">  ep_free(ep);</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AfterNotes:</p><p><code>ep_alloc</code> allocates slab cache.</p><p>Anonymous inode here is only available to the parent process, this is generally a good way to get a temporary file.</p><h2 id="File-Operations-of-Epoll"><a href="#File-Operations-of-Epoll" class="headerlink" title="File Operations of Epoll"></a>File Operations of Epoll</h2><p>The epoll instance is also pollable as a normal file. This allows us to monitor epoll instances with select, poll or even epoll itself!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">eventpoll_fops</span> =</span> &#123;</span><br><span class="line">  .show_fdinfo  = ep_show_fdinfo,</span><br><span class="line">  .release  = ep_eventpoll_release,</span><br><span class="line">  .poll   = ep_eventpoll_poll,</span><br><span class="line">  .llseek   = noop_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*release closes file and llseek repositions the offset of the open file descriptor.*/</span></span><br><span class="line"><span class="keyword">__poll_t</span> (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line"><span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line"><span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h2><p><code>struct event poll</code> is quite complicated.</p><p>The most important fields are:</p><ul><li>rbtree root</li><li>rdlist (ready list)</li><li>ovflist (overflow list)</li><li>epfd file pointer</li><li>wait queue of poll_wait epoll itself</li><li>wait queue of syscall epoll_wait, the wait queue in process scheduling.</li></ul><p>Epoll uses Red-Black Tree to listen on file descriptors. Keys are of type  <code>struct epoll_filefd</code>  , values of type <code>struct epitem</code>. Keys are compared by applying pointer arithmetic on file pointer address, and then comaring absoluted size of fds.</p><p><code>fdget</code> can also be used to implement key compare, but its a lot slower.</p><p><code>epi</code> are also in slab cache，since <code>ep_insert</code> calls <code>kmem_cache_alloc</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// file defined in &lt;linux/fs.h&gt;</span></span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></figure><p>ep_find is classic Red-Black Tree node search.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct epitem *<span class="title">ep_find</span><span class="params">(struct eventpoll *ep, struct file *file, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> kcmp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rbp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">epir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line">​</span><br><span class="line">  ep_set_ffd(&amp;ffd, file, fd);</span><br><span class="line">  <span class="keyword">for</span> (rbp = ep-&gt;rbr.rb_root.rb_node; rbp; ) &#123;</span><br><span class="line">    epi = rb_entry(rbp, struct epitem, rbn);</span><br><span class="line">    kcmp = ep_cmp_ffd(&amp;ffd, &amp;epi-&gt;ffd);</span><br><span class="line">    <span class="keyword">if</span> (kcmp &gt; <span class="number">0</span>)</span><br><span class="line">      rbp = rbp-&gt;rb_right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (kcmp &lt; <span class="number">0</span>)</span><br><span class="line">      rbp = rbp-&gt;rb_left;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      epir = epi;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> epir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each file descriptor added to the eventpoll interface will</span></span><br><span class="line"><span class="comment"> * have an entry of this type linked to the &quot;rbr&quot; RB tree.</span></span><br><span class="line"><span class="comment"> * Avoid increasing the size of this struct, there can be many thousands</span></span><br><span class="line"><span class="comment"> * of these on a server and we do not want this to take another cache line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RB tree node links this structure to the eventpoll RB tree</span></span><br><span class="line"><span class="comment">    * epitems are Values of the KV pair nodes in the RedblackTree</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">    <span class="comment">/* Used to free the struct epitem</span></span><br><span class="line"><span class="comment">    * RCU=Read-Copy Update Lock, lock for rbtree nodes</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* List header used to link this structure to the eventpoll ready list</span></span><br><span class="line"><span class="comment">  * &quot;struct eventpoll&quot;-&gt;rdlist</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">   * single linked chain of items. ovflist (overflow list) is used when we are</span></span><br><span class="line"><span class="comment">   * copying rdlist(ready list) from kernel space to user space</span></span><br><span class="line"><span class="comment">   * using epoll_wait.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* The file descriptor information this item refers to. </span></span><br><span class="line"><span class="comment">  * Rbtree key.</span></span><br><span class="line"><span class="comment">  * Contains file* and fd. See struct epoll_filefd definition above. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">  <span class="keyword">int</span> nwait;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* List containing poll wait queues.</span></span><br><span class="line"><span class="comment">  * This wait queue is the linux file system defined wait queue in &lt;linux/wait.h&gt;</span></span><br><span class="line"><span class="comment">  * Items in pwq list have type struct eppoll_entry.</span></span><br><span class="line"><span class="comment">  * It is a glue struct that links epitem to its wait_queue_entry and wait_queue_head</span></span><br><span class="line"><span class="comment">  *  (the head of the target file&#x27;s wait queue). Given a wait_queue_entry </span></span><br><span class="line"><span class="comment">  * we can calculate its epitem and eppoll_entry using pointer arithmetic.</span></span><br><span class="line"><span class="comment">  * However, normally a single epitem has only 1 epoll_entry linked to 1 wait queue </span></span><br><span class="line"><span class="comment">  * waiting on 1 file, it seems strange to have a linked list.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* The &quot;container&quot; of this item</span></span><br><span class="line"><span class="comment">  * The epoll instance, core of this piece of code.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list </span></span><br><span class="line"><span class="comment">  * Again, this normally contains only 1 item.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* wakeup_source used when EPOLLWAKEUP is set */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> __<span class="title">rcu</span> *<span class="title">ws</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* The structure that describe the interested events and the source fd</span></span><br><span class="line"><span class="comment">  *  One of the input structs in epoll system call.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Locks above are all RCU locks. Readers don’t need to get locks to read，since writers write on a copy and uses a callback function to change redirect pointer of old struct to the new copy. Lock-free preformance with many readers (except context-switch). CPU context switches are called quiescent state, readers need to wait for a signal that all CPUs have finished context switch (grace period). GC also occurs here.</p><h2 id="Callbacks-in-Epoll"><a href="#Callbacks-in-Epoll" class="headerlink" title="Callbacks in Epoll"></a>Callbacks in Epoll</h2><p><code>wait_queue_entry</code>s with callbacks packed inside are placed in wait queues of files being listened to, upon being available, they wake up all other threads in the wait queue and then links the <code>epitem</code> it is associated with to <code>epi-&gt;rdllink</code>, in the ready list of the epitem. Thus syscall epoll_wait needs only to retreive all ready fds from ready lists. Though it looks as if only ready list pointers are stored, but actually epitem pointers and ready list pointers can be transformed through pointer arithmetic.</p><p>wait_queue is deifined in <code>&lt;linux/wait.h&gt;</code>. <code>wait_queue_func_t</code> func is the callback function we want to look at, and epoll registers <code>ep_poll_callback</code> here。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</span><br><span class="line">  <span class="keyword">void</span>      *<span class="keyword">private</span>;</span><br><span class="line">  <span class="keyword">wait_queue_func_t</span> func;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">entry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* wait_queue_func_t  func is wake up function */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">wait_queue_func_t</span>)</span><span class="params">(struct wait_queue_entry *wq_entry, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>;</span><br></pre></td></tr></table></figure><p>There is a problem here that，<code>wait_queue_heads</code> for different files are placed in different places, thus we need a <code>eppoll_entry</code> glue struct to encapsulate wait queue structs and epitems.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> &#123;</span></span><br><span class="line">  <span class="comment">/* List header used to link this structure to the &quot;struct epitem&quot;, </span></span><br><span class="line"><span class="comment">  *  its struct list_head pwqlist.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span></span><br><span class="line">  <span class="comment">/* The &quot;base&quot; pointer is set to the container &quot;struct epitem&quot; */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">base</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait queue entry that will be linked to the target file wait</span></span><br><span class="line"><span class="comment">   * queue. It has a wake up function pointer in it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">wait_queue_entry_t</span> wait;</span><br><span class="line">  <span class="comment">/* The wait queue head that linked the &quot;wait&quot; wait queue item</span></span><br><span class="line"><span class="comment">  * It is stored at different places according to the particular </span></span><br><span class="line"><span class="comment">  * file implemenntation, take tcp as an example, it is sk_wq </span></span><br><span class="line"><span class="comment">  * stored inside the struct sock struct. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">wait_queue_head_t</span> *whead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>So how exactly do we place call_backs in the wait_queue in epoll?</p><p>We can see that <code>ep_insert</code> registers callbacks:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line">...</span><br><span class="line">epq.epi = epi;</span><br><span class="line">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"><span class="comment">/* ep_item_poll calls the corresponding file&#x27;s poll() implementation */</span></span><br><span class="line">revents = ep_item_poll(epi, &amp;epq.pt, <span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* glue struct to connect poll_table with epitem*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> &#123;</span></span><br><span class="line">  poll_table pt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">  poll_queue_proc _qproc;</span><br><span class="line">  <span class="keyword">__poll_t</span> _key;</span><br><span class="line">&#125; poll_table;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * structures and helpers for f_op-&gt;poll implementations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead, poll_table *pt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_poll</span><span class="params">(struct file *file, struct socket *sock, poll_table *wait)</span></span>;</span><br></pre></td></tr></table></figure><p><code>poll_queue_proc</code> is <code>poll</code> in file operation tables of different files, kernel code in<code>&lt;linux/poll.h&gt;</code>. For example, it is <code>tcp_poll();</code> for tcp sockets and <code>ep_ptable_queue_proc</code> for epoll.</p><p><code>ep_pqueue</code> is glue struct for connecting <code>poll_table</code> to <code>epitem</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is the callback that is used to add our wait queue to the</span></span><br><span class="line"><span class="comment">* target file wakeup lists.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead, poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* use pointer arithmetic from glue struct ep_pqueue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_epqueue(pt);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line"><span class="comment">/* init wait_queue_entry-&gt;wait_queue_func_tfunc as ep_poll_callback</span></span><br><span class="line"><span class="comment">* add the wait_queue_entry to the files wait queue，Register ep_poll_callback() as wake   * queue wakeup function.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">    pwq-&gt;whead = whead;</span><br><span class="line">    pwq-&gt;base = epi;</span><br><span class="line">    add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">    list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line"><span class="comment">/* As stated above, nwait is normally 1 */</span></span><br><span class="line">    epi-&gt;nwait++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ep_poll_callback</code> actually enters wait queues of files. We have seen above that it places files into ready lists and wakes up other threads in the queue.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_entry_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* use glue struct eppoll_entry to get epitem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_wait(wait);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> epi-&gt;ep;</span><br><span class="line">    <span class="keyword">__poll_t</span> pollflags = key_to_poll(key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> ewake = <span class="number">0</span>;</span><br><span class="line">    read_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    ep_set_busy_poll_napi_id(epi);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the event mask does not contain any poll(2) event, we consider the</span></span><br><span class="line"><span class="comment"> * descriptor to be disabled. This condition is likely the effect of the</span></span><br><span class="line"><span class="comment"> * EPOLLONESHOT bit that disables the descriptor when an event is received,</span></span><br><span class="line"><span class="comment"> * until the next EPOLL_CTL_MOD will be issued.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check the events coming with the callback. We had earlier set key_ to ~u0, </span></span><br><span class="line"><span class="comment"> * to listen to all events, but at this stage, not</span></span><br><span class="line"><span class="comment"> * every device reports the events in the &quot;key&quot; parameter of the</span></span><br><span class="line"><span class="comment"> * callback. We need to be able to handle both cases here, hence the</span></span><br><span class="line"><span class="comment"> * test for &quot;key&quot; != NULL before the event match test.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (pollflags &amp;&amp; !(pollflags &amp; epi-&gt;event.events))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are transferring events to userspace which makes rdlist unusable</span></span><br><span class="line"><span class="comment"> * (via s y syscall epoll_wait()) we can hold no locks (because we read user space</span></span><br><span class="line"><span class="comment">   * memory, and because of linux f_op-&gt;poll() semantics). All the events that </span></span><br><span class="line"><span class="comment"> * happen during that period of time are chained in ep-&gt;ovflist as overflow list </span></span><br><span class="line"><span class="comment"> * and requeued to rdlist later on after transfer event has finished.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR &amp;&amp;</span><br><span class="line">            chain_epi_lockless(epi))</span><br><span class="line">            ep_pm_stay_awake_rcu(epi);</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If this file is already in the ready list we exit soon, this happens</span></span><br><span class="line"><span class="comment">* when user does not call epoll_wait() for a long time. Else, we add it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (!ep_is_linked(epi) &amp;&amp;</span><br><span class="line">        list_add_tail_lockless(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        ep_pm_stay_awake_rcu(epi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wake up ( if active, which means not empty) both the eventpoll wait list and the -&gt;poll()</span></span><br><span class="line"><span class="comment"> * wait list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((epi-&gt;event.events &amp; EPOLLEXCLUSIVE) &amp;&amp;</span><br><span class="line">                    !(pollflags &amp; POLLFREE)) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (pollflags &amp; EPOLLINOUT_BITS) &#123;</span><br><span class="line">            <span class="keyword">case</span> EPOLLIN:</span><br><span class="line">                <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLIN)</span><br><span class="line">                    ewake = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EPOLLOUT:</span><br><span class="line">                <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLOUT)</span><br><span class="line">                    ewake = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                ewake = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/* Wait queue used by syscall epoll_wait() */</span></span><br><span class="line">        wake_up(&amp;ep-&gt;wq);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* epoll Wait queue as a file, pwake keeps track of levels of reference */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line">out_unlock:</span><br><span class="line">    read_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE))</span><br><span class="line">        ewake = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pollflags &amp; POLLFREE) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we race with ep_remove_wait_queue() it can miss</span></span><br><span class="line"><span class="comment"> * -&gt;whead = NULL and do another remove_wait_queue() after</span></span><br><span class="line"><span class="comment"> * us, so we can&#x27;t use __remove_wait_queue().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        list_del_init(&amp;wait-&gt;entry);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;whead != NULL protects us from the race with ep_free()</span></span><br><span class="line"><span class="comment"> * or ep_remove(), ep_remove_wait_queue() takes whead-&gt;lock</span></span><br><span class="line"><span class="comment"> * held by the caller. Once we nullify it, nothing protects</span></span><br><span class="line"><span class="comment"> * ep/epi or even wait.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        smp_store_release(&amp;ep_pwq_from_wait(wait)-&gt;whead, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ewake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ep_item_poll</code>will poll the file using <code>vfs_poll</code>，i.e. <code>f_op-&gt;poll</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_item_poll</span><span class="params">(<span class="keyword">const</span> struct epitem *epi, poll_table *pt,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> locked;</span><br><span class="line">    pt-&gt;_key = epi-&gt;event.events;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(epi-&gt;ffd.file))</span><br><span class="line">    <span class="comment">/* If it is not an epoll file, vfs_poll calls corresponding f_op-&gt;poll </span></span><br><span class="line"><span class="comment">    * of the file, tcp_poll for example.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">return</span> vfs_poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class="line">    ep = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">  <span class="comment">/* If the file is an epoll, do another level of poll_wait, call ep_ptable_queue_proc again*/</span></span><br><span class="line">    poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt);</span><br><span class="line">    locked = pt &amp;&amp; (pt-&gt;_qproc == ep_ptable_queue_proc);</span><br><span class="line">    <span class="keyword">return</span> ep_scan_ready_list(epi-&gt;ffd.file-&gt;private_data,</span><br><span class="line">                  ep_read_events_proc, &amp;depth, depth,</span><br><span class="line">                  locked) &amp; epi-&gt;event.events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">__poll_t</span> <span class="title">vfs_poll</span><span class="params">(struct file *file, struct poll_table_struct *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!file-&gt;f_op-&gt;poll))</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_POLLMASK;</span><br><span class="line">    <span class="keyword">return</span> file-&gt;f_op-&gt;poll(file, pt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ET-and-LT"><a href="#ET-and-LT" class="headerlink" title="ET and LT"></a>ET and LT</h2><p>ET(Edge Trigger) and LT(Level Trigger)<br>LT is default. It always puts all epitems back to ready lists, returns them back to user again and again at <code>epoll_wait</code>, thus it is repeatedly triggered. For ET, user only hears about them once in <code>epoll_wait</code>. ET assumes that user can handle event immediately after being notified. (Not a good assumption in most cases).</p><p>After copying data, if there are more epitems on the ready list, LT may wake up all <code>ep_&gt;wq</code> and <code>ep-&gt;poll_wait</code> processes. Some times this wake up process is too frequent.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wake up (if active) both the eventpoll wait list and</span></span><br><span class="line"><span class="comment">     * the -&gt;poll() wait list (delayed after we release the lock).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">      wake_up(&amp;ep-&gt;wq);</span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">      pwake++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Create&quot;&gt;&lt;a href=&quot;#Create&quot; class=&quot;headerlink&quot; title=&quot;Create&quot;&gt;&lt;/a&gt;Create&lt;/h2&gt;&lt;p&gt;We start with epoll_create. &lt;code&gt;epoll_create&lt;/code&gt; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Job Search China</title>
    <link href="https://anxue.xyz/blog/2020/JobSearch/"/>
    <id>https://anxue.xyz/blog/2020/JobSearch/</id>
    <published>2020-04-14T17:09:49.000Z</published>
    <updated>2021-04-15T16:02:26.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="China-market"><a href="#China-market" class="headerlink" title="China market"></a>China market</h2><p><a href="https://gitee.com/ChiZhung/CS-Notes">https://gitee.com/ChiZhung/CS-Notes</a></p><div class="row">    <embed src="../../../../test/test.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;China-market&quot;&gt;&lt;a href=&quot;#China-market&quot; class=&quot;headerlink&quot; title=&quot;China market&quot;&gt;&lt;/a&gt;China market&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://gitee.com/Chi</summary>
      
    
    
    
    
  </entry>
  
</feed>
