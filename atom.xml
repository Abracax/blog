<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abracax&#39;s Notes</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-14T17:52:58.321Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Abracat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jump Table to Superb Blog Posts</title>
    <link href="http://example.com/2021/04/15/JumpTable/"/>
    <id>http://example.com/2021/04/15/JumpTable/</id>
    <published>2021-04-14T17:13:28.000Z</published>
    <updated>2021-04-14T17:52:58.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p><a href="http://lwn.net/Articles/250967/">http://lwn.net/Articles/250967/</a></p><p><a href="https://searchstorage.techtarget.com/definition/NVRAM-non-volatile-random-access-memory">https://searchstorage.techtarget.com/definition/NVRAM-non-volatile-random-access-memory</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Memory&quot;&gt;&lt;a href=&quot;#Memory&quot; class=&quot;headerlink&quot; title=&quot;Memory&quot;&gt;&lt;/a&gt;Memory&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://lwn.net/Articles/250967/&quot;&gt;http://lwn.n</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>WAFL &amp; Shadow Paging</title>
    <link href="http://example.com/2021/04/14/WAFL/"/>
    <id>http://example.com/2021/04/14/WAFL/</id>
    <published>2021-04-14T14:02:07.000Z</published>
    <updated>2021-04-14T18:01:52.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shadow-Paging"><a href="#Shadow-Paging" class="headerlink" title="Shadow Paging"></a>Shadow Paging</h2><p>Shadow paging is a copy-on-write technique for avoiding in-place updates of pages. Instead, when a page is to be modified, a shadow page is allocated. When the page is ready to become durable, all pages that referred to the original are updated to refer to the new replacement page instead. Because the page is “activated” only when it is ready, it is atomic.</p><h2 id="Read-Through-Write-Through-Write-Behind-Caching-and-Refresh-Ahead"><a href="#Read-Through-Write-Through-Write-Behind-Caching-and-Refresh-Ahead" class="headerlink" title="Read-Through, Write-Through, Write-Behind Caching and Refresh-Ahead"></a>Read-Through, Write-Through, Write-Behind Caching and Refresh-Ahead</h2><p>WAFL uses write-behind caching, NVRAM as a cache of unwritten disk blocks.  This means <strong>cache</strong> layer itself connects to the backing database. This means that your applications need only ever connect to your <strong>cache</strong> layer.</p><p><a href="https://docs.oracle.com/cd/E13924_01/coh.340/e13819/readthrough.htm">https://docs.oracle.com/cd/E13924_01/coh.340/e13819/readthrough.htm</a></p><p>WAFL gathers up many hundreds of NFS requests before scheduling a write episode. During a write episode, WAFL allocates disk space for all the dirty data in the cache and schedules the required disk I/O. </p><h2 id="Same-as-EXT2-except-Snapshots"><a href="#Same-as-EXT2-except-Snapshots" class="headerlink" title="Same as EXT2 except Snapshots"></a>Same as EXT2 except Snapshots</h2><p>Metadata:</p><ul><li>inode file</li><li>block-map file (free blocks)</li><li> inode-map (free inodes)</li></ul><p>Keeping meta-data in files makes it easy to increase the size of the file system on the fly. </p><p>4 KB blocks. Each WAFL inode contains 16 block pointers to indicate which blocks belong to the file. Inodes for larger files point to doubly indirect blocks. For very small files, data is stored in the inode itself in place of the block pointers.</p><p>The write-anywhere design good for distributing writes evenly across RAID.</p><h2 id="Snapshots"><a href="#Snapshots" class="headerlink" title="Snapshots"></a>Snapshots</h2><p>WAFL simply duplicates the root inode. Makes snapshot at consistency point every 10 seconds.</p><p>WAFL uses non-volatile RAM (NVRAM) to keep a log of NFS requests it has processed since the last consistency point. After an unclean shutdown, WAFL replays any requests in the log to prevent them from being lost. </p><ul><li>WAFL can write any file system block (except the one containing the root inode) to any location on disk. </li><li>WAFL can write blocks to disk in any order.</li><li>WAFL can allocate disk space for many NFS operations at once in a single write episode.</li></ul><p>WAFL’s technique for keeping Snapshot data self consistent is to mark all the dirty data in the cache as “IN_SNAPSHOT.” The rule during Snapshot creation is that data marked IN_SNAPSHOT must not be modified, and data not marked IN_SNAPSHOT must not be flushed to disk. WAFL must flush IN_SNAPSHOT data as quickly as possible. </p><ul><li>Allocate disk space for all files with IN_SNAPSHOT blocks. WAFL caches inode data in two places: in a special cache of in-core inodes, and in disk buffers belonging to the inode file.  WAFL copies the newly updated inode information from the inode cache into the appropriate inode file disk buffer, and clears the IN_SNAPSHOT bit on the in-core inode. <strong>No disk access.</strong> <strong>Quick.</strong></li><li>Update the block-map file. </li><li>Flush IN_SNAPSHOT disk buffers to disk, can start NFS requests.</li><li>Duplicate the root inode, turn the root inode’s IN_SNAPSHOT bit off.  Reach the disk last.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shadow-Paging&quot;&gt;&lt;a href=&quot;#Shadow-Paging&quot; class=&quot;headerlink&quot; title=&quot;Shadow Paging&quot;&gt;&lt;/a&gt;Shadow Paging&lt;/h2&gt;&lt;p&gt;Shadow paging is a copy-on</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ARIES</title>
    <link href="http://example.com/2021/04/14/ARIES/"/>
    <id>http://example.com/2021/04/14/ARIES/</id>
    <published>2021-04-14T11:13:20.000Z</published>
    <updated>2021-04-14T20:25:37.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stealing-and-Forcing"><a href="#Stealing-and-Forcing" class="headerlink" title="Stealing and Forcing"></a>Stealing and Forcing</h2><p>Stealing happens when buffer pool is full, pages modified by uncommitted transactions can get kicked into stable storage.</p><p>Forcing means that every time a transaction commits, all the affected pages will be pushed to stable storage.</p><p>STEAL or NO-STEAL – Can an update made by an uncommitted transaction overwrite the most recent committed value of a data item on disk?</p><p>FORCE or NO-FORCE – Should all updates of a transaction be forced to disk before the transaction commits?</p><ul><li>Easiest for recovery: NO-STEAL/FORCE</li><li>Highest performance: STEAL/NO-FORCE</li><li>Undo logging: Steal/Force<ul><li>uncommmited writes?</li><li>output early</li></ul></li><li>Redo logging: No-Steal/No-Force<ul><li>commited stuff not written</li><li>output late</li></ul></li></ul><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>The recovery works in three phases.</p><ul><li>The first phase, <strong>Analysis</strong>, computes all the necessary information from the logfile.  Rebuild active transactions table and dirty pages table.</li><li><strong>Redo</strong> some transaction that did commit. Replay history, starting from first recLSN, page granularity. The <strong>Redo</strong> phase restores the database to the exact state at the crash, including all the changes of uncommitted transactions that were running at that point in time.</li><li><strong>Undo</strong> other transactions that didn’t commit. The <strong>Undo</strong> phase then undoes all uncommitted changes, leaving the database in a consistent state. Only affects log entries. Write to log as CLR (Compensating log records), redone never undone.</li></ul><h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>All log records pertaining to a page are written to disk before the page is overwritten on disk.</p><p>All log records for transaction are written to disk before the transaction is considered committed.</p><h2 id="Granularity"><a href="#Granularity" class="headerlink" title="Granularity"></a>Granularity</h2><ul><li>Page-oriented logging for REDO (element=one page)</li><li>Logical logging for UNDO (element=one record)</li></ul><p>Actual logs logical operations within a page.</p><h2 id="Checkpoints"><a href="#Checkpoints" class="headerlink" title="Checkpoints"></a>Checkpoints</h2><p>Write into the log</p><p>–  Entire active transactions table</p><p> –  Entire dirty page table</p><h2 id="ARIES-Data-Structures"><a href="#ARIES-Data-Structures" class="headerlink" title="ARIES Data Structures"></a>ARIES Data Structures</h2><ul><li>Active Transactions Table, &lt;trans_id, lastLSN&gt;</li><li>Dirty Page Table, &lt;page_id, recLSN&gt;</li><li>Write Ahead Log, &lt;LSN, prevLSN, trnas_id, page_id, log_entry&gt;</li><li>Buffer pool = table of  pairs  &lt;PageLSN, page_id&gt;</li></ul><p>LSN= log sequence number, LSN’s help us find the end of a circular log file.</p><p>lastLSN = most recent update by transaction</p><p>recoveryLSN (recLSN)= first LSN that caused page to become dirty</p><p>prevLSN = previous LSN for same transaction</p><h2 id="Aries-Steps"><a href="#Aries-Steps" class="headerlink" title="Aries Steps"></a>Aries Steps</h2><ul><li>Add log record</li><li>Update transactions table</li><li>Update dirty page table</li><li>Update pageLSN</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Stealing-and-Forcing&quot;&gt;&lt;a href=&quot;#Stealing-and-Forcing&quot; class=&quot;headerlink&quot; title=&quot;Stealing and Forcing&quot;&gt;&lt;/a&gt;Stealing and Forcing&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CUDA ECE 408</title>
    <link href="http://example.com/2020/11/15/CUDA/"/>
    <id>http://example.com/2020/11/15/CUDA/</id>
    <published>2020-11-14T16:53:19.000Z</published>
    <updated>2021-04-14T17:03:01.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sparse-Matrix-Vector-Multiplication"><a href="#Sparse-Matrix-Vector-Multiplication" class="headerlink" title="Sparse Matrix-Vector Multiplication"></a>Sparse Matrix-Vector Multiplication</h2><p><strong>M rows, N columns, K non-zeros, L non-zero elements in the row with the largest number of non-zeros.</strong></p><p>COO: 3K</p><p>CSR: 2K + M + 1</p><p>ELL: 2M*L</p><p>JDS: 2K+2M</p><p>JDS-T: 2K + 2M + L</p><p>Aligned accesses need to start at a 16-word boundary and threads in a warp need to access continuous locations. Non-aligned need not start at a 16-word boundary. Whereas coalesced just means that threads in a warp need to access continuous locations. Transposition helps reduce non-coalesced accesses.</p><p><strong>ELL</strong> best for control divergence.</p><p><strong>ELL</strong> and <strong>JDS-T</strong> coalesced</p><p><img src="/2020/11/15/CUDA/image-20201209004919794.png" alt="image-20201209004919794"></p><p><img src="/2020/11/15/CUDA/image-20201209004948402.png" alt="image-20201209004948402"></p><p><img src="/2020/11/15/CUDA/image-20201209005013410.png" alt="image-20201209005013410"></p><p><img src="/2020/11/15/CUDA/image-20201209005036563.png" alt="image-20201209005036563"></p><h2 id="Kogge-Stone-scan-kernel"><a href="#Kogge-Stone-scan-kernel" class="headerlink" title="Kogge-Stone scan kernel"></a>Kogge-Stone scan kernel</h2><p>Total # of add operations: n * log(n) - (n-1)</p><h3 id="Control-Divergence"><a href="#Control-Divergence" class="headerlink" title="Control Divergence"></a>Control Divergence</h3><p>1024 elements  where stride is 16: 1 warp</p><p>1024 elements  where stride is 64: 0 warp</p><h2 id="Brent-Kung-Scan-kernel"><a href="#Brent-Kung-Scan-kernel" class="headerlink" title="Brent-Kung Scan kernel"></a>Brent-Kung Scan kernel</h2><p>Total # of add operations:  2*(n-1) – log(n)</p><h2 id="Privatisation-and-Histogramming"><a href="#Privatisation-and-Histogramming" class="headerlink" title="Privatisation and Histogramming"></a>Privatisation and Histogramming</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">histo_kernel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">long</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> *histo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> __shared__ <span class="keyword">unsigned</span> <span class="keyword">int</span> histo_private[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = threadIdx.x; i &lt; <span class="number">1024</span>; i+=blockDim.x) histo_privat[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> __syncthreads();</span><br><span class="line"> <span class="keyword">int</span> i = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stride is total number of threads </span></span><br><span class="line"><span class="keyword">int</span> stride = blockDim.x * gridDim.x</span><br><span class="line"><span class="keyword">while</span> (i &lt; size) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( buffer[i]... ) atomicAdd( &amp;(private_histo[buffer[i]), <span class="number">1</span>); </span><br><span class="line">  <span class="keyword">else</span> atomicAdd( &amp;(histo[buffer[i]), <span class="number">1</span> );</span><br><span class="line">  i += stride; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="number">2048</span>; i += <span class="number">1</span>)</span><br><span class="line">    atomicAdd( &amp;(histo[buffer[i]),  private_histo[buffer[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Theoretical-minimum-runtime-of-the-original-histogram-kernel"><a href="#Theoretical-minimum-runtime-of-the-original-histogram-kernel" class="headerlink" title="Theoretical minimum runtime of the original histogram kernel"></a>Theoretical minimum runtime of the <strong>original histogram kernel</strong></h4><ol><li><p>(blockDim*loop_num) *largest_percentage * 1 ns + gridDim * 100 ns</p><p>Loop_num is also number of elements per thread.</p></li></ol><p><img src="/2020/11/15/CUDA/image-20201208224920842.png" alt="image-20201208224920842"></p><p>10**7 + 5000</p><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><p>dim3 outputDim(W_out, H_out, 1);</p><p>dim3 inputDim(W, H, 1);</p><ol><li>OutputDim maps to the output so it will use fewer threads, this also has less control divergence if using shared memory and strategy 2. inputDim maps to the input so it can load the shared memory in a single pass.</li></ol><h2 id="Convolution-calculation"><a href="#Convolution-calculation" class="headerlink" title="Convolution calculation"></a>Convolution calculation</h2><p>For input elements</p><p>– Each output tile has TILE_WIDTH^2 elements<br> – Each input tile has (TILE_WIDTH+K-1)^2<br> – The total number of input feature map element accesses was TILE_WIDTH^2 * K^2<br> – The reduction factor of the tiled algorithm is K^2 * TILE_WIDTH^2 / (TILE_WIDTH+K-1)^2</p><h2 id="Unroll"><a href="#Unroll" class="headerlink" title="Unroll"></a>Unroll</h2><p><img src="/2020/11/15/CUDA/image-20201209094952824.png" alt="image-20201209094952824"></p><p><img src="/2020/11/15/CUDA/image-20201209095014432.png" alt="image-20201209095014432"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Sparse-Matrix-Vector-Multiplication&quot;&gt;&lt;a href=&quot;#Sparse-Matrix-Vector-Multiplication&quot; class=&quot;headerlink&quot; title=&quot;Sparse Matrix-Vector M</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>EPOLL</title>
    <link href="http://example.com/2020/07/06/EPOLL/"/>
    <id>http://example.com/2020/07/06/EPOLL/</id>
    <published>2020-07-06T11:13:27.000Z</published>
    <updated>2021-04-14T11:14:34.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p>We start with epoll_create. <code>epoll_create</code> can have an input flag EPOLL_CLOEXEC. O_CLOEXEC means close on <code>execve()</code>.</p><p>O_CLOEXEC avoids race conditions where one thread opens a file descriptor at the same time as another thread does a <code>fork() + execve()</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create1, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> do_epoll_create(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So <code>epoll_create</code>tells us to look at <code>do_epoll_create</code>.</p><p>Must clarify some ambiguous abbreviated variable names before code:</p><ul><li>The fds epoll registers in the VFS are called <code>epfd</code></li><li><code>struct eventpoll</code> has variable name <code>ep</code></li><li><code>epi</code> has variable name of <code>epitem</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_epoll_create</span><span class="params">(<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> error, fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* Check the EPOLL_* constant for consistency.  */</span></span><br><span class="line">  BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Create the internal data structure (&quot;struct eventpoll&quot;).</span></span><br><span class="line"><span class="comment">   * ep_alloc uses kzalloc, slab cache quickens memory use.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  error = ep_alloc(&amp;ep);</span><br><span class="line">  <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Creates all the items needed to setup an eventpoll file. </span></span><br><span class="line"><span class="comment">   * Get an unused file descriptor and an anonymous inode file, use fd_install to bind them.</span></span><br><span class="line"><span class="comment">   * Set file operations: poll, release, llseek. </span></span><br><span class="line"><span class="comment">   * release closes file and llseek repositions the offset of the open file descriptor.</span></span><br><span class="line"><span class="comment">   * See eventpoll_fops below.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC)</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    error = fd;</span><br><span class="line">    <span class="keyword">goto</span> out_free_ep;</span><br><span class="line">  &#125;</span><br><span class="line">  file = anon_inode_getfile(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">         O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">    error = PTR_ERR(file);</span><br><span class="line">    <span class="keyword">goto</span> out_free_fd;</span><br><span class="line">  &#125;</span><br><span class="line">  ep-&gt;file = file;</span><br><span class="line">  fd_install(fd, file);</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">​</span><br><span class="line">out_free_fd:</span><br><span class="line">  put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">  ep_free(ep);</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AfterNotes:</p><p><code>ep_alloc</code> allocates slab cache.</p><p>Anonymous inode here is only available to the parent process, this is generally a good way to get a temporary file.</p><h2 id="File-Operations-of-Epoll"><a href="#File-Operations-of-Epoll" class="headerlink" title="File Operations of Epoll"></a>File Operations of Epoll</h2><p>The epoll instance is also pollable as a normal file. This allows us to monitor epoll instances with select, poll or even epoll itself!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">eventpoll_fops</span> =</span> &#123;</span><br><span class="line">  .show_fdinfo  = ep_show_fdinfo,</span><br><span class="line">  .release  = ep_eventpoll_release,</span><br><span class="line">  .poll   = ep_eventpoll_poll,</span><br><span class="line">  .llseek   = noop_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*release closes file and llseek repositions the offset of the open file descriptor.*/</span></span><br><span class="line"><span class="keyword">__poll_t</span> (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line"><span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line"><span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h2><p><code>struct event poll</code> is quite complicated.</p><p>The most important fields are:</p><ul><li>rbtree root</li><li>rdlist (ready list)</li><li>ovflist (overflow list)</li><li>epfd file pointer</li><li>wait queue of poll_wait epoll itself</li><li>wait queue of syscall epoll_wait, the wait queue in process scheduling.</li></ul><p>Epoll uses Red-Black Tree to listen on file descriptors. Keys are of type  <code>struct epoll_filefd</code>  , values of type <code>struct epitem</code>. Keys are compared by applying pointer arithmetic on file pointer address, and then comaring absoluted size of fds.</p><p><code>fdget</code> can also be used to implement key compare, but its a lot slower.</p><p><code>epi</code> are also in slab cache，since <code>ep_insert</code> calls <code>kmem_cache_alloc</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// file defined in &lt;linux/fs.h&gt;</span></span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></figure><p>ep_find is classic Red-Black Tree node search.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct epitem *<span class="title">ep_find</span><span class="params">(struct eventpoll *ep, struct file *file, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> kcmp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rbp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">epir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line">​</span><br><span class="line">  ep_set_ffd(&amp;ffd, file, fd);</span><br><span class="line">  <span class="keyword">for</span> (rbp = ep-&gt;rbr.rb_root.rb_node; rbp; ) &#123;</span><br><span class="line">    epi = rb_entry(rbp, struct epitem, rbn);</span><br><span class="line">    kcmp = ep_cmp_ffd(&amp;ffd, &amp;epi-&gt;ffd);</span><br><span class="line">    <span class="keyword">if</span> (kcmp &gt; <span class="number">0</span>)</span><br><span class="line">      rbp = rbp-&gt;rb_right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (kcmp &lt; <span class="number">0</span>)</span><br><span class="line">      rbp = rbp-&gt;rb_left;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      epir = epi;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> epir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each file descriptor added to the eventpoll interface will</span></span><br><span class="line"><span class="comment"> * have an entry of this type linked to the &quot;rbr&quot; RB tree.</span></span><br><span class="line"><span class="comment"> * Avoid increasing the size of this struct, there can be many thousands</span></span><br><span class="line"><span class="comment"> * of these on a server and we do not want this to take another cache line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RB tree node links this structure to the eventpoll RB tree</span></span><br><span class="line"><span class="comment">    * epitems are Values of the KV pair nodes in the RedblackTree</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">    <span class="comment">/* Used to free the struct epitem</span></span><br><span class="line"><span class="comment">    * RCU=Read-Copy Update Lock, lock for rbtree nodes</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* List header used to link this structure to the eventpoll ready list</span></span><br><span class="line"><span class="comment">  * &quot;struct eventpoll&quot;-&gt;rdlist</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">   * single linked chain of items. ovflist (overflow list) is used when we are</span></span><br><span class="line"><span class="comment">   * copying rdlist(ready list) from kernel space to user space</span></span><br><span class="line"><span class="comment">   * using epoll_wait.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* The file descriptor information this item refers to. </span></span><br><span class="line"><span class="comment">  * Rbtree key.</span></span><br><span class="line"><span class="comment">  * Contains file* and fd. See struct epoll_filefd definition above. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">  <span class="keyword">int</span> nwait;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* List containing poll wait queues.</span></span><br><span class="line"><span class="comment">  * This wait queue is the linux file system defined wait queue in &lt;linux/wait.h&gt;</span></span><br><span class="line"><span class="comment">  * Items in pwq list have type struct eppoll_entry.</span></span><br><span class="line"><span class="comment">  * It is a glue struct that links epitem to its wait_queue_entry and wait_queue_head</span></span><br><span class="line"><span class="comment">  *  (the head of the target file&#x27;s wait queue). Given a wait_queue_entry </span></span><br><span class="line"><span class="comment">  * we can calculate its epitem and eppoll_entry using pointer arithmetic.</span></span><br><span class="line"><span class="comment">  * However, normally a single epitem has only 1 epoll_entry linked to 1 wait queue </span></span><br><span class="line"><span class="comment">  * waiting on 1 file, it seems strange to have a linked list.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* The &quot;container&quot; of this item</span></span><br><span class="line"><span class="comment">  * The epoll instance, core of this piece of code.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list </span></span><br><span class="line"><span class="comment">  * Again, this normally contains only 1 item.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* wakeup_source used when EPOLLWAKEUP is set */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> __<span class="title">rcu</span> *<span class="title">ws</span>;</span></span><br><span class="line">​</span><br><span class="line">  <span class="comment">/* The structure that describe the interested events and the source fd</span></span><br><span class="line"><span class="comment">  *  One of the input structs in epoll system call.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Locks above are all RCU locks. Readers don’t need to get locks to read，since writers write on a copy and uses a callback function to change redirect pointer of old struct to the new copy. Lock-free preformance with many readers (except context-switch). CPU context switches are called quiescent state, readers need to wait for a signal that all CPUs have finished context switch (grace period). GC also occurs here.</p><h2 id="Callbacks-in-Epoll"><a href="#Callbacks-in-Epoll" class="headerlink" title="Callbacks in Epoll"></a>Callbacks in Epoll</h2><p><code>wait_queue_entry</code>s with callbacks packed inside are placed in wait queues of files being listened to, upon being available, they wake up all other threads in the wait queue and then links the <code>epitem</code> it is associated with to <code>epi-&gt;rdllink</code>, in the ready list of the epitem. Thus syscall epoll_wait needs only to retreive all ready fds from ready lists. Though it looks as if only ready list pointers are stored, but actually epitem pointers and ready list pointers can be transformed through pointer arithmetic.</p><p>wait_queue is deifined in <code>&lt;linux/wait.h&gt;</code>. <code>wait_queue_func_t</code> func is the callback function we want to look at, and epoll registers <code>ep_poll_callback</code> here。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</span><br><span class="line">  <span class="keyword">void</span>      *<span class="keyword">private</span>;</span><br><span class="line">  <span class="keyword">wait_queue_func_t</span> func;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">entry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* wait_queue_func_t  func is wake up function */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">wait_queue_func_t</span>)</span><span class="params">(struct wait_queue_entry *wq_entry, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>;</span><br></pre></td></tr></table></figure><p>There is a problem here that，<code>wait_queue_heads</code> for different files are placed in different places, thus we need a <code>eppoll_entry</code> glue struct to encapsulate wait queue structs and epitems.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> &#123;</span></span><br><span class="line">  <span class="comment">/* List header used to link this structure to the &quot;struct epitem&quot;, </span></span><br><span class="line"><span class="comment">  *  its struct list_head pwqlist.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span></span><br><span class="line">  <span class="comment">/* The &quot;base&quot; pointer is set to the container &quot;struct epitem&quot; */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">base</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait queue entry that will be linked to the target file wait</span></span><br><span class="line"><span class="comment">   * queue. It has a wake up function pointer in it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">wait_queue_entry_t</span> wait;</span><br><span class="line">  <span class="comment">/* The wait queue head that linked the &quot;wait&quot; wait queue item</span></span><br><span class="line"><span class="comment">  * It is stored at different places according to the particular </span></span><br><span class="line"><span class="comment">  * file implemenntation, take tcp as an example, it is sk_wq </span></span><br><span class="line"><span class="comment">  * stored inside the struct sock struct. </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">wait_queue_head_t</span> *whead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>So how exactly do we place call_backs in the wait_queue in epoll?</p><p>We can see that <code>ep_insert</code> registers callbacks:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line">...</span><br><span class="line">epq.epi = epi;</span><br><span class="line">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"><span class="comment">/* ep_item_poll calls the corresponding file&#x27;s poll() implementation */</span></span><br><span class="line">revents = ep_item_poll(epi, &amp;epq.pt, <span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* glue struct to connect poll_table with epitem*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> &#123;</span></span><br><span class="line">  poll_table pt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">  poll_queue_proc _qproc;</span><br><span class="line">  <span class="keyword">__poll_t</span> _key;</span><br><span class="line">&#125; poll_table;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * structures and helpers for f_op-&gt;poll implementations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead, poll_table *pt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_poll</span><span class="params">(struct file *file, struct socket *sock, poll_table *wait)</span></span>;</span><br></pre></td></tr></table></figure><p><code>poll_queue_proc</code> is <code>poll</code> in file operation tables of different files, kernel code in<code>&lt;linux/poll.h&gt;</code>. For example, it is <code>tcp_poll();</code> for tcp sockets and <code>ep_ptable_queue_proc</code> for epoll.</p><p><code>ep_pqueue</code> is glue struct for connecting <code>poll_table</code> to <code>epitem</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is the callback that is used to add our wait queue to the</span></span><br><span class="line"><span class="comment">* target file wakeup lists.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead, poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* use pointer arithmetic from glue struct ep_pqueue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_epqueue(pt);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line"><span class="comment">/* init wait_queue_entry-&gt;wait_queue_func_tfunc as ep_poll_callback</span></span><br><span class="line"><span class="comment">* add the wait_queue_entry to the files wait queue，Register ep_poll_callback() as wake   * queue wakeup function.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">    pwq-&gt;whead = whead;</span><br><span class="line">    pwq-&gt;base = epi;</span><br><span class="line">    add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">    list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line"><span class="comment">/* As stated above, nwait is normally 1 */</span></span><br><span class="line">    epi-&gt;nwait++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ep_poll_callback</code> actually enters wait queues of files. We have seen above that it places files into ready lists and wakes up other threads in the queue.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_entry_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* use glue struct eppoll_entry to get epitem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_wait(wait);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> epi-&gt;ep;</span><br><span class="line">    <span class="keyword">__poll_t</span> pollflags = key_to_poll(key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> ewake = <span class="number">0</span>;</span><br><span class="line">    read_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    ep_set_busy_poll_napi_id(epi);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the event mask does not contain any poll(2) event, we consider the</span></span><br><span class="line"><span class="comment"> * descriptor to be disabled. This condition is likely the effect of the</span></span><br><span class="line"><span class="comment"> * EPOLLONESHOT bit that disables the descriptor when an event is received,</span></span><br><span class="line"><span class="comment"> * until the next EPOLL_CTL_MOD will be issued.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check the events coming with the callback. We had earlier set key_ to ~u0, </span></span><br><span class="line"><span class="comment"> * to listen to all events, but at this stage, not</span></span><br><span class="line"><span class="comment"> * every device reports the events in the &quot;key&quot; parameter of the</span></span><br><span class="line"><span class="comment"> * callback. We need to be able to handle both cases here, hence the</span></span><br><span class="line"><span class="comment"> * test for &quot;key&quot; != NULL before the event match test.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (pollflags &amp;&amp; !(pollflags &amp; epi-&gt;event.events))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are transferring events to userspace which makes rdlist unusable</span></span><br><span class="line"><span class="comment"> * (via s y syscall epoll_wait()) we can hold no locks (because we read user space</span></span><br><span class="line"><span class="comment">   * memory, and because of linux f_op-&gt;poll() semantics). All the events that </span></span><br><span class="line"><span class="comment"> * happen during that period of time are chained in ep-&gt;ovflist as overflow list </span></span><br><span class="line"><span class="comment"> * and requeued to rdlist later on after transfer event has finished.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR &amp;&amp;</span><br><span class="line">            chain_epi_lockless(epi))</span><br><span class="line">            ep_pm_stay_awake_rcu(epi);</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If this file is already in the ready list we exit soon, this happens</span></span><br><span class="line"><span class="comment">* when user does not call epoll_wait() for a long time. Else, we add it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (!ep_is_linked(epi) &amp;&amp;</span><br><span class="line">        list_add_tail_lockless(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        ep_pm_stay_awake_rcu(epi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wake up ( if active, which means not empty) both the eventpoll wait list and the -&gt;poll()</span></span><br><span class="line"><span class="comment"> * wait list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((epi-&gt;event.events &amp; EPOLLEXCLUSIVE) &amp;&amp;</span><br><span class="line">                    !(pollflags &amp; POLLFREE)) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (pollflags &amp; EPOLLINOUT_BITS) &#123;</span><br><span class="line">            <span class="keyword">case</span> EPOLLIN:</span><br><span class="line">                <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLIN)</span><br><span class="line">                    ewake = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EPOLLOUT:</span><br><span class="line">                <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLOUT)</span><br><span class="line">                    ewake = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                ewake = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/* Wait queue used by syscall epoll_wait() */</span></span><br><span class="line">        wake_up(&amp;ep-&gt;wq);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* epoll Wait queue as a file, pwake keeps track of levels of reference */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line">out_unlock:</span><br><span class="line">    read_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE))</span><br><span class="line">        ewake = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pollflags &amp; POLLFREE) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we race with ep_remove_wait_queue() it can miss</span></span><br><span class="line"><span class="comment"> * -&gt;whead = NULL and do another remove_wait_queue() after</span></span><br><span class="line"><span class="comment"> * us, so we can&#x27;t use __remove_wait_queue().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        list_del_init(&amp;wait-&gt;entry);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;whead != NULL protects us from the race with ep_free()</span></span><br><span class="line"><span class="comment"> * or ep_remove(), ep_remove_wait_queue() takes whead-&gt;lock</span></span><br><span class="line"><span class="comment"> * held by the caller. Once we nullify it, nothing protects</span></span><br><span class="line"><span class="comment"> * ep/epi or even wait.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        smp_store_release(&amp;ep_pwq_from_wait(wait)-&gt;whead, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ewake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ep_item_poll</code>will poll the file using <code>vfs_poll</code>，i.e. <code>f_op-&gt;poll</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_item_poll</span><span class="params">(<span class="keyword">const</span> struct epitem *epi, poll_table *pt,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> locked;</span><br><span class="line">    pt-&gt;_key = epi-&gt;event.events;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(epi-&gt;ffd.file))</span><br><span class="line">    <span class="comment">/* If it is not an epoll file, vfs_poll calls corresponding f_op-&gt;poll </span></span><br><span class="line"><span class="comment">    * of the file, tcp_poll for example.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">return</span> vfs_poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class="line">    ep = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">  <span class="comment">/* If the file is an epoll, do another level of poll_wait, call ep_ptable_queue_proc again*/</span></span><br><span class="line">    poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt);</span><br><span class="line">    locked = pt &amp;&amp; (pt-&gt;_qproc == ep_ptable_queue_proc);</span><br><span class="line">    <span class="keyword">return</span> ep_scan_ready_list(epi-&gt;ffd.file-&gt;private_data,</span><br><span class="line">                  ep_read_events_proc, &amp;depth, depth,</span><br><span class="line">                  locked) &amp; epi-&gt;event.events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">__poll_t</span> <span class="title">vfs_poll</span><span class="params">(struct file *file, struct poll_table_struct *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!file-&gt;f_op-&gt;poll))</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_POLLMASK;</span><br><span class="line">    <span class="keyword">return</span> file-&gt;f_op-&gt;poll(file, pt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ET-and-LT"><a href="#ET-and-LT" class="headerlink" title="ET and LT"></a>ET and LT</h2><p>ET(Edge Trigger) and LT(Level Trigger)<br>LT is default. It always puts all epitems back to ready lists, returns them back to user again and again at <code>epoll_wait</code>, thus it is repeatedly triggered. For ET, user only hears about them once in <code>epoll_wait</code>. ET assumes that user can handle event immediately after being notified. (Not a good assumption in most cases).</p><p>After copying data, if there are more epitems on the ready list, LT may wake up all <code>ep_&gt;wq</code> and <code>ep-&gt;poll_wait</code> processes. Some times this wake up process is too frequent.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wake up (if active) both the eventpoll wait list and</span></span><br><span class="line"><span class="comment">     * the -&gt;poll() wait list (delayed after we release the lock).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">      wake_up(&amp;ep-&gt;wq);</span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">      pwake++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Create&quot;&gt;&lt;a href=&quot;#Create&quot; class=&quot;headerlink&quot; title=&quot;Create&quot;&gt;&lt;/a&gt;Create&lt;/h2&gt;&lt;p&gt;We start with epoll_create. &lt;code&gt;epoll_create&lt;/code&gt; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Job Search China</title>
    <link href="http://example.com/2020/04/15/JobSearch/"/>
    <id>http://example.com/2020/04/15/JobSearch/</id>
    <published>2020-04-14T17:09:49.000Z</published>
    <updated>2021-04-15T16:02:26.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="China-market"><a href="#China-market" class="headerlink" title="China market"></a>China market</h2><p><a href="https://gitee.com/ChiZhung/CS-Notes">https://gitee.com/ChiZhung/CS-Notes</a></p><div class="row">    <embed src="../../../../test/test.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;China-market&quot;&gt;&lt;a href=&quot;#China-market&quot; class=&quot;headerlink&quot; title=&quot;China market&quot;&gt;&lt;/a&gt;China market&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://gitee.com/Chi</summary>
      
    
    
    
    
  </entry>
  
</feed>
