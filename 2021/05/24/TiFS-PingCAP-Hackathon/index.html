<!DOCTYPE html><html lang="en"><head><title>Abracax</title><link rel="alternate" href="/atom.xml" type="application/atom.xml"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"><link href="https://fonts.googleapis.com/css?family=Playfair+Display" rel="stylesheet"><script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"></script><script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"></script><meta charset="UTF-8"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Abracax's Notes" type="application/atom+xml">
</head><body><div class="site-header"><div class="container"><div class="site-branding"><h1 class="site-title">Abracax's Notes<a href="google.com"></a></h1><div class="site-description"><span class="site-description-text"></span></div></div></div></div><div class="menu_box"><div class="menucon"><nav class="navbar navbar-expand-lg navbar-light bg-light"><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><div class="menucon"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="/resume">About Me</a></li></ul></div><div class="menucon"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="/">Blog</a></li></ul></div><div class="menucon"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" target="_blank" rel="noopener" href="https://github.com/abracax">GitHub</a></li></ul></div><div class="menucon"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="/cv/">Download CV</a></li></ul></div></div></nav></div></div></body><div class="container"><div class="row"><div class="single-post"><article class="post-block"><h1 class="post-title">TiFS: PingCAP Hackathon With XiXi, 龙姐姐, GG</h1><header class="headgallery"></header><div class="row"><div class="tag-box"><div class="tags"></div></div></div><div class="post-content"><h2 id="TiFS-a-TiKV-Based-Partition-Tolerant-Strictly-Consistent-File-System"><a href="#TiFS-a-TiKV-Based-Partition-Tolerant-Strictly-Consistent-File-System" class="headerlink" title="TiFS, a TiKV-Based Partition Tolerant, Strictly Consistent File System"></a>TiFS, a TiKV-Based Partition Tolerant, Strictly Consistent File System</h2><p><a target="_blank" rel="noopener" href="https://github.com/Hexilee/tifs">https://github.com/Hexilee/tifs</a></p>
<p>Author: Hexi Lee (Software Engineer Intern at PingCAP)</p>
<p>Transcreator: Ran Huang; Editor: Tom Dewan</p>
<p>TiKV is a distributed key-value storage engine, featuring strong consistency and partition tolerance. It can act either as the storage engine for TiDB or as an independent transactional key-value database. Do you know what else it is capable of?</p>
<p>At TiDB Hackathon 2020, our team built a TiKV-based distributed POSIX file system, TiFS, which inherits the powerful features of TiKV and also taps into TiKV’s possibilities beyond data storage.</p>
<p>In this post, I’ll walk you through every detail of TiFS: how we came up with the idea, how we implemented the file system, and its benchmarking results. Let the hacking begin!</p>
<h3 id="Why-build-a-file-system-based-on-TiKV"><a href="#Why-build-a-file-system-based-on-TiKV" class="headerlink" title="Why build a file system based on TiKV?"></a>Why build a file system based on TiKV?</h3><p>A “distributed” system has multiple processes cooperating across machines; TiKV has that as well. Being a distributed database means it easily scales out and is fault tolerant by nature.</p>
<p>A friend of mine once wanted to try out TiDB but had only one server. I told him that he could run a TiKV instance on each disk, achieving data disaster tolerance, and wouldn’t need RAID anymore!</p>
<p>However, TiKV stores only data—not files—so you still need RAID to recover your files from a disaster. But it sparked an idea in me: if TiKV could store the file system data, then it could achieve disaster recovery for the file system. So we spent several days building TiFS. It was a POSIX file system and in the first version was bug-ridden and prone to deadlocks—but hey, the idea worked.</p>
<p>Why did we go to all this effort? Three reasons:</p>
<p>Unlike the common storage backend for distributed file systems, TiKV supports ACID-compliant distributed transactions. Therefore, we can guarantee strict consistency of the file system.<br>A POSIX file system not only covers the requirements of a local file system, but also supports file collaboration across machines and stores files for other distributed applications.<br>What’s even cooler, if we run a standalone application that supports multi-instance collaboration on TiFS, it becomes a distributed application.<br>Therefore, we started this project to build TiFS, a file system that is as strong as Titanium.</p>
<h3 id="How-we-implement-TiFS"><a href="#How-we-implement-TiFS" class="headerlink" title="How we implement TiFS"></a>How we implement TiFS</h3><p>TiKV only provides a simple key-value store, where keys and values are byte arrays with unfixed length. Therefore, before implementing the file system, we need to divide the logical area for keys and construct the data structure for values.</p>
<h4 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h4><p>TiFS stores seven types of values in TiKV: system metadata, file metadata, file block, file handler, symbolic link, directory, and file index. The file block is transparent data written by the user. The symbolic link only stores the target path. The other five values are structured data.</p>
<h4 id="System-metadata"><a href="#System-metadata" class="headerlink" title="System metadata"></a>System metadata</h4><p>The whole file system has only one system metadata (Meta), which is updated only during the mknod and mkdir operations. System metadata contains only one integer used to generate the file inode number:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meta</span></span> &#123;</span><br><span class="line">    inode_next: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File-metadata"><a href="#File-metadata" class="headerlink" title="File metadata"></a>File metadata</h4><p>Each file has a corresponding file metadata (Inode). In this data structure:</p>
<p>file_attr stores the metadata required for a POSIX file system, such as the file inode number, the file size, and the number of blocks. See Rust File Attributes for details.<br>lock_state tracks the current lock state and the lock holder, which are used to implement flock.<br>inline_data stores a small amount of file content to improve the read/write performance of tiny files.<br>next_fn is an auto-increment integer used to generate the file handler.<br>opened_fn records the number of opened file handlers.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inode</span></span> &#123;</span><br><span class="line">    file_attr: FileAttr,</span><br><span class="line">    lock_state: LockState,</span><br><span class="line">    inline_data: <span class="built_in">Option</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt;,</span><br><span class="line">    next_fh: <span class="built_in">u64</span>,</span><br><span class="line">    opened_fh: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File-handler"><a href="#File-handler" class="headerlink" title="File handler"></a>File handler</h4><p>Every time the user calls open, the file system generates a corresponding file handler (FileHandler) to store the read/write limits of the handler:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileHandler</span></span> &#123;</span><br><span class="line">    flags: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h4><p>Each directory stores a list of subfiles so that it can implement readdir. In the list, each DirItem item stores the inode number, name, and type of file:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Directory</span></span> = <span class="built_in">Vec</span>&lt;DirItem&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DirItem</span></span> &#123;</span><br><span class="line">    ino: <span class="built_in">u64</span>,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    typ: FileType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="File-index"><a href="#File-index" class="headerlink" title="File index"></a>File index</h4><p>When we query a file, the file system can traverse the whole file directory; but to query files more efficiently, we create an index (Index) for each file. The file index only contains the inode number of the target file:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Index</span></span> &#123;</span><br><span class="line">    ino: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h4><p>TiFS has five types of keys: system metadata, file metadata, file block, file handler, and file index. Among them, the file block key stores the file block data, symbolic link, and directory, while the other four keys store their corresponding values.</p>
<p>The first byte of the block, also known as the scope, identifies the type of key. The key’s byte arrays usually follows this pattern:</p>
<ul>
<li><p>1 byte +&lt;——————————–+ dynamic size +—————————————&gt;+<br>|        |                                                                                         |<br>|        |                                                                                         |<br>|        |                                                                                         |<br>|        |                                                                                         |<br>|        |                                                                                         |<br>|        |                                                                                         |<br>|        v                                                                                         v</p>
</li>
<li><p>————————————————————————————————–+<br>|        |                                                                                         |<br>|  scope |                                         key                                             |<br>|        |                                                                                         |</p>
</li>
<li><p>——–+—————————————————————————————–+<br>The system metadata scope has only one key-value pair:</p>
</li>
<li><p>1 byte +<br>|        |<br>|        |<br>|        |<br>|        |<br>|        |<br>|        |<br>|        v</p>
</li>
<li><p>——–+<br>|        |<br>|    0   |<br>|        |</p>
</li>
<li><p>——–+<br>The file metadata key only contains the inode number in big-endian ordering so that all the file metadata are sequentially stored in TiKV. Thus, for the statfs operation, we can get all the file metadata using TiKV’s scan interface.</p>
</li>
</ul>
<p>The file metadata key is as follows:</p>
<ul>
<li>1 byte +&lt;———————————-+ 8 bytes +——————————————&gt;+<br>|        |                                                                                         |<br>|        |                                                                                         |<br>|        |                                                                                         |<br>|        |                                                                                         |<br>|        |                                                                                         |<br>|        |                                                                                         |<br>|        v                                                                                         v</li>
<li>————————————————————————————————–+<br>|        |                                                                                         |<br>|    1   |                                     inode number                                        |<br>|        |                                                                                         |</li>
<li>——–+—————————————————————————————–+<br>The file block key is composed of the file inode number and the block index in big-endian ordering. All file blocks for a single file are sequentially stored in TiKV. When we need to read large chunks of data, we can get the desired file blocks by one scan.</li>
</ul>
<p>The key’s array is listed below:</p>
<ul>
<li><p>1 byte +&lt;—————- 8 bytes —————&gt;+&lt;—————— 8 bytes —————–&gt;+<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        v                                          v                                              v</p>
</li>
<li><p>————————————————————————————————–+<br>|        |                                          |                                              |<br>|    2   |              inode number                |                   block index                |<br>|        |                                          |                                              |</p>
</li>
<li><p>——–+——————————————+———————————————-+<br>The file handler key consists of the file inode number and the file handler number in big-endian ordering:</p>
</li>
<li><p>1 byte +&lt;—————- 8 bytes —————&gt;+&lt;—————— 8 bytes —————–&gt;+<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        v                                          v                                              v</p>
</li>
<li><p>————————————————————————————————–+<br>|        |                                          |                                              |<br>|    3   |              inode number                |                  file handler                |<br>|        |                                          |                                              |</p>
</li>
<li><p>——–+——————————————+———————————————-+<br>The file index key includes the inode number of its parent directory in big-endian ordering and the file name in UTF-8 encoding:</p>
</li>
<li><p>1 byte +&lt;—————- 8 bytes —————&gt;+&lt;—————— 8 bytes —————–&gt;+<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        |                                          |                                              |<br>|        v                                          v                                              v</p>
</li>
<li><p>————————————————————————————————–+<br>|        |                                          |                                              |<br>|    4   |     inode number of parent directory     |         file name in utf-8 encoding          |<br>|        |                                          |                                              |</p>
</li>
<li><p>——–+——————————————+———————————————-+</p>
</li>
</ul>
<h4 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h4><p>TiKV supports both optimistic and pessimistic transactions. However, since the Rust client only supports pessimistic transactions experimentally, and pessimistic transactions may reduce performance when transactions don’t conflict, we implement TiFS by optimistic transactions only.</p>
<h4 id="Various-scenarios"><a href="#Various-scenarios" class="headerlink" title="Various scenarios"></a>Various scenarios</h4><p>TiFS is most efficient for reading and writing small files or other complicated file system operations. Although TiFS can handle large files, compared to other large file storage solutions it is not as powerful or efficient.</p>
<p>Here are a few uses of TiFS that you may find interesting:</p>
<p>A Git remote repository can directly use TiFS to store the project and run Git tasks, such as rebase or cherry-pick, without transferring the files to the local file system.<br>When multiple nodes of an application read or write the same file in TiFS, you can use flock to resolve any conflicts.<br>There’s no complicated SDK or API for space management. You simply call the file system API or run a shell script.<br>TiFS lets you take a standalone application that supports multi-instance collaboration and turn it into a distributed application. For example, SQLite + TiFS = yet another distributed relational database. Admittedly, to use TiFS this way, the application cannot rely on page cache or other caching mechanisms to avoid writes being invisible.</p>
<p><a href="tifs-makes-sqlite-another-distributed-relational-database.gif"></a></p>
<h3 id="Tests-and-benchmarks"><a href="#Tests-and-benchmarks" class="headerlink" title="Tests and benchmarks"></a>Tests and benchmarks</h3><p>During the Hackathon, we used pjdfstest to test TiFS’s correctness. But because pjdfstest doesn’t cover read/write correctness or concurrency correctness, we will need to add other tests.</p>
<p>Theoretically, there are three major factors that influence the read/write performance of TiFS: the size of file system blocks, the network latency, and the size of load blocks. Here we’ll show the benchmarking results of the read/write IOPS and speed.</p>
<h4 id="IOPS"><a href="#IOPS" class="headerlink" title="IOPS"></a>IOPS</h4><p>Note: TiKV is a sophisticated system, in which there are logical duration, disk I/O duration, and network duration. In this article, we simplify TiKV to a single replica for demonstration purposes.</p>
<p>Let’s first take a look at IOPS. Because sequential reads and writes perform I/O operations linearly, each I/O operation is a transaction in TiKV. If we ignore the minor differences between each operation, the duration of an I/O operation, T, is the reciprocal of IOPS. In addition, if we don’t count stream processing, we can consider T as the linear addition of the following four variables:</p>
<p>Tf: the I/O duration of FUSE.<br>Tc: the logical duration of TiFS.<br>Tn: the network transmission time.<br>Ts: the logical duration of TiKV.<br>Accordingly, we have this equation:</p>
<h5 id="Read-IOPS"><a href="#Read-IOPS" class="headerlink" title="Read IOPS"></a>Read IOPS</h5><p>For read operations, Tf is positively correlated to the size of load blocks. The size of data read or written by TiFS per I/O operation must be an integer multiple of the size of file system blocks. Therefore, Tn and Ts are positively correlated to the larger value between load blocks and file system blocks; however, with larger traffic, network and disk I/O may take longer. Tc is unknown.</p>
<p>The following diagram shows how the sequential read IOPS varies with the size of load blocks. The four lines represent different filesystem block sizes and data replicas.</p>
<h6 id="Read-IOPS-benchmarking-results"><a href="#Read-IOPS-benchmarking-results" class="headerlink" title="Read IOPS benchmarking results"></a>Read IOPS benchmarking results</h6><p>Before the benchmarking, we had the following projections:</p>
<p>When both the file block and load block are 4 KB, if the load block increases, Tf, Tn, and Ts increase; therefore, IOPS decreases.<br>When the file block is 64 KB or 1 MB:<br>If the load block is smaller than the file block, Tn and Ts barely change, but Tf increases; therefore, IOPS decreases.<br>If the load block is larger than the file block, Tf, Tn, and Ts all increase; therefore, IOPS decreases.<br>As you can see in the diagram, the variation is almost identical to our projections.</p>
<h5 id="Write-IOPS"><a href="#Write-IOPS" class="headerlink" title="Write IOPS"></a>Write IOPS</h5><p>When TiFS sequentially writes data, if the load block is smaller than the file block, TiFS needs to read a dirty block, which causes extra Tc and Tn. When the file block is large, that extra overhead is noticeable.</p>
<p>The following line chart shows how the sequential write IOPS varies with the size of the load blocks. When the file blocks are 1 MB (see the yellow line), the IOPS is largest while the file block and load block are equivalent.</p>
<h6 id="Write-IOPS-benchmarking-results"><a href="#Write-IOPS-benchmarking-results" class="headerlink" title="Write IOPS benchmarking results"></a>Write IOPS benchmarking results</h6><p>Moreover, we can see that the red line almost overlaps the blue line on the first two data points. This means when the load block and file block are 4 KB or 64 KB, their IOPS values are nearly the same. Under such circumstances, the minimum traffic per second is 4 KB 110 = 440 KB, and the maximum is 64 KB 100 = 6.25 MB, both putting little pressure on the network and disks. When the traffic is small enough, it is safe to say that IOPS reaches its upper limit, so the major factor of Tn becomes network latency. (In local testing, Tn is considered 0 ms.)</p>
<p>In the chart above, when file blocks and load blocks change between 4 KB and 64 KB, IOPS is almost unaffected. Under such configurations, T is determined by Tc and Ts, so we call it the fixed system operation latency of TiFS. The fixed system operation latency is caused by TiFS and TiKV’s logical duration. If the latency is high enough, it leads to terrible read/write performance for small files. We are still working on this optimization.</p>
<h4 id="Speed"><a href="#Speed" class="headerlink" title="Speed"></a>Speed</h4><p>Because the read and write speeds are the product of IOPS multiplied by load blocks, and IOPS changes very little when the load block increases from 4 KB to 1 MB, read and write speeds reach the maximum value when the load block is 1 MB.</p>
<p>The following two bar charts compare the read and write speeds in different cluster configurations when the load block is 1 MB. The blue bar represents ordinary TiKV, while the red bar represents TiKV with Titan enabled.</p>
<p>Titan is a RocksDB Plugin for key-value separation, inspired by WiscKey, to reduce write amplification.</p>
<p>From the charts, we can see that the write speed is mostly affected by the file block size and whether Titan is enabled, and that the read speed is only slightly fluctuating. This is because the smaller the file block is, the more key-value pairs TiKV writes into, which takes more time. But RocksDB performs poorly with large file blocks, so enabling Titan can reduce unnecessary value copy and thus improve performance.</p>
<h4 id="Our-next-step"><a href="#Our-next-step" class="headerlink" title="Our next step"></a>Our next step</h4><p>In TiFS, storing file blocks is very costly because TiKV implements redundancy by using multiple replicas (three by default). The redundancy ratio (occupied space divided by written data volume) is usually three or more.</p>
<p>However, the redundancy ratio is as low as 1.2~1.5 in other distributed file systems that support redundancy by erasure coding (EC), such as HDFS, CephFS, and JuiceFS. EC redundancy requires encoding and decoding during data write and reconstruction, which consumes extra computing resources. However, the EC redundancy strategy sacrifices part of the read performance in exchange for lower network overhead and storage cost.</p>
<p>Currently, it is somewhat difficult for TiKV to support EC, but we plan to support EC-redundancy object storage for file blocks to reduce storage cost.</p>
<p>Apart from that, we’ll focus on verifying correctness and tuning performance:</p>
<p>For correctness, we’ll research how other file systems are tested and use that knowledge to build our own tests.<br>For performance, we’ll cover both TiFS and TiKV to reduce the innate latency.<br>If you are interested in TiFS, feel free to try it out or join our discussion!</p>
<p>At TiDB Hackathon 2020, many excellent, interesting projects were born. We’ll be telling you about them in future blog posts. Stay tuned.</p>
</div></article><div class="paginator"><a class="prev" href="/2021/05/27/Modern-Philosophy/">prev</a><a class="next" href="/2021/04/15/JumpTable/">next</a></div></div></div></div><div class="container-fluid"><div class="row"><div class="footer_box"><a class="col-lg-2 col-xl-2 col-md-2" href="/resume">Contact</a></div></div></div></html>