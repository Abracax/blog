<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  <meta name="referrer" content="unsafe-url">
  
  <title>C++ Interview Prep</title>
  <meta name="author" content="Abracat">
  <meta name="description" content="char * const  &amp;amp; const char *The difference is that const char * is a pointer to a const char, while char * const is a constant pointer to a char.
">
  
  
  <meta property="og:title" content="C++ Interview Prep"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="Abracax&#39;s Notes"/>
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/blog/atom.xml" title="Abracax&#39;s Notes" type="application/atom+xml">
  <link rel="stylesheet" href="/blog/css/m.min.css">
  <link rel="icon" type="image/x-icon" href="/blog/favicon.ico">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>

</head>

<body>
  <a id="top"></a>
  <div id="main">
    <div class="main-ctnr">
      <div class="behind">
  <a href="/blog/" class="back black-color">
    <svg class="i-close" viewBox="0 0 32 32" width="22" height="22" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
        <path d="M2 30 L30 2 M30 30 L2 2"></path>
    </svg>
  </a>
  
</div>


  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        C++ Interview Prep
    </h1>
  


    </div>
    <div class="meta center">
      <time datetime="2021-08-12T12:05:05.000Z" itemprop="datePublished">
  <svg class="i-calendar" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
    <path d="M2 6 L2 30 30 30 30 6 Z M2 15 L30 15 M7 3 L7 9 M13 3 L13 9 M19 3 L19 9 M25 3 L25 9"></path>
  </svg>
  &nbsp;
  2021-08-12
</time>






    </div>
    <hr>
    
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#char-const-amp-const-char"><span class="toc-text">char * const  &amp; const char *</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shared-Pointer-amp-Cyclic-Reference"><span class="toc-text">Shared Pointer &amp; Cyclic Reference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr%E3%80%81shared-ptr-and-weak-ptr"><span class="toc-text">unique_ptr、shared_ptr and weak_ptr.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reference-Count"><span class="toc-text">Reference Count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Why-auto-ptr-is-banned"><span class="toc-text">Why auto_ptr is banned</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Constructors-the-big-4"><span class="toc-text">Constructors, the big 4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Initializor-List"><span class="toc-text">Initializor List</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual"><span class="toc-text">Virtual</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-function-table"><span class="toc-text">Virtual function table</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Polymorphism-in-C"><span class="toc-text">Polymorphism in C++</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Const-in-C"><span class="toc-text">Const in C++</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Const-member-functions"><span class="toc-text">Const member functions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Const-Classes"><span class="toc-text">Const Classes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Const-variables"><span class="toc-text">Const variables</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-in-C"><span class="toc-text">Static in C++</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Static-variables-in-a-Function"><span class="toc-text">Static variables in a Function:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Static-variables-in-a-class"><span class="toc-text">Static variables in a class</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Class-objects-as-static"><span class="toc-text">Class objects as static</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Static-functions-in-a-class"><span class="toc-text">Static functions in a class</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTTI-Run-Time-Type-Information"><span class="toc-text">RTTI (Run-Time Type Information)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pure-virtual-functions-and-virtual-functions"><span class="toc-text">Pure virtual functions and virtual functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Protected"><span class="toc-text">Protected</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Concurrency"><span class="toc-text">Concurrency</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-of-Blocking-Queue"><span class="toc-text">Example of Blocking Queue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Singleton"><span class="toc-text">Singleton</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-sort"><span class="toc-text">STL sort</span></a></li></ol>
    
    <div class="picture-container">
      
    </div>
    <h2 id="char-const-amp-const-char"><a href="#char-const-amp-const-char" class="headerlink" title="char * const  &amp; const char *"></a>char * const  &amp; const char *</h2><p>The difference is that <code>const char *</code> is a pointer to a <code>const char</code>, while <code>char * const</code> is a constant pointer to a <code>char</code>.</p>
<p><code>const char *</code> and <code>char const *</code> are equivalent.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>       *      mutable_pointer_to_mutable_int;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *      mutable_pointer_to_constant_int;</span><br><span class="line"><span class="keyword">int</span>       *<span class="keyword">const</span> constant_pointer_to_mutable_int;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *<span class="keyword">const</span> constant_pointer_to_constant_int;</span><br></pre></td></tr></table></figure>


<h2 id="Shared-Pointer-amp-Cyclic-Reference"><a href="#Shared-Pointer-amp-Cyclic-Reference" class="headerlink" title="Shared Pointer &amp; Cyclic Reference"></a>Shared Pointer &amp; Cyclic Reference</h2><p>Use <code>weak_ptr</code>.  Lets say <code>A</code> owns <code>B</code> but <code>B</code> does not own <code>A</code> then we replace the reference to <code>A</code> in <code>B</code> with a <code>weak_ptr</code></p>
<h3 id="unique-ptr、shared-ptr-and-weak-ptr"><a href="#unique-ptr、shared-ptr-and-weak-ptr" class="headerlink" title="unique_ptr、shared_ptr and weak_ptr."></a>unique_ptr、shared_ptr and weak_ptr.</h3><h4 id="Reference-Count"><a href="#Reference-Count" class="headerlink" title="Reference Count"></a>Reference Count</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>())</span></span>;</span><br><span class="line">p1.<span class="built_in">use_count</span>();</span><br><span class="line">p1.<span class="built_in">reset</span>();</span><br><span class="line">p1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">34</span>)); <span class="keyword">or</span> p1 = <span class="literal">nullptr</span>; </span><br></pre></td></tr></table></figure>

<h4 id="Why-auto-ptr-is-banned"><a href="#Why-auto-ptr-is-banned" class="headerlink" title="Why auto_ptr is banned"></a>Why auto_ptr is banned</h4><p>The <strong>copy semantics</strong> of <code>auto_ptr</code> are not compatible with the containers.</p>
<p>Specifically, copying one <code>auto_ptr</code> to another does not create two equal objects since one has lost its ownership of the pointer.</p>
<h2 id="Constructors-the-big-4"><a href="#Constructors-the-big-4" class="headerlink" title="Constructors, the big 4"></a>Constructors, the big 4</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cs225 &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">char</span>* s;</span><br><span class="line">      <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// const variables must be initialized using Initializer List</span></span><br><span class="line">    	<span class="comment">// Reference members must be initialized using Initializer List.</span></span><br><span class="line">    	<span class="comment">// For initialization of member objects which do not have default constructor</span></span><br><span class="line">    	<span class="built_in">String</span>():<span class="built_in">s</span>(<span class="literal">NULL</span>), <span class="built_in">size</span>(<span class="number">5</span>)&#123;&#125;</span><br><span class="line">      <span class="built_in">String</span>(<span class="keyword">char</span>*); <span class="comment">// constructor</span></span><br><span class="line">    	<span class="built_in">String</span>(<span class="keyword">const</span> String s&amp;);</span><br><span class="line">      ~<span class="built_in">String</span>(); <span class="comment">// destructor, </span></span><br><span class="line">    	String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; b) <span class="comment">// Copy assignment operator</span></span><br><span class="line">      &#123;</span><br><span class="line">          x = b.x;</span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// operator= ( const String&amp;) = default;</span></span><br><span class="line">    <span class="comment">// operator= ( const String&amp;) = delete;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">char</span>* c)</span><br><span class="line">&#123;</span><br><span class="line">    size = <span class="built_in">strlen</span>(c);</span><br><span class="line">    s = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(s, c);</span><br><span class="line">&#125;</span><br><span class="line">String::~<span class="built_in">String</span>() &#123; <span class="keyword">delete</span>[] s; &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Copy constructor is called when a new object is created from an existing object, as a copy of the existing object.</li>
<li>Assignment operator is called when an already initialized object is assigned a new value from another existing object.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Test t1, t2; </span><br><span class="line">    t2 = t1; <span class="comment">// calls assignment operator, same as &quot;t2.operator=(t1);&quot;</span></span><br><span class="line">    Test t3 = t1; <span class="comment">// calls copy constructor, same as &quot;Test t3(t1);&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="Initializor-List"><a href="#Initializor-List" class="headerlink" title="Initializor List"></a>Initializor List</h3><p> Initialization lists get completely executed <em>before</em> entering the constructor block.</p>
<ul>
<li>non-static const variables must be initialized using Initializer List</li>
<li>Reference members must be initialized using Initializer List.</li>
<li>For initialization of member objects which do not have default constructor<ul>
<li>If class A had both default and parameterized constructors, then Initializer List is not must if we want to initialize “a” using default constructor, but it is must to initialize “a” using parameterized constructor. </li>
</ul>
</li>
<li>For initialization of base class members<ul>
<li>Like point 3, the parameterized constructor of the base class can only be called using Initializer List.</li>
</ul>
</li>
<li>When constructor’s parameter name is same as data member<ul>
<li><code>A::A(int i):i(i) &#123; &#125;</code></li>
</ul>
</li>
</ul>
<h2 id="Virtual"><a href="#Virtual" class="headerlink" title="Virtual"></a>Virtual</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;  <span class="comment">// = 0 means it is &quot;pure virtual&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Shape* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span>  ~<span class="built_in">Shape</span>();<span class="comment">// Ensures to invoke actual object destructor</span></span><br><span class="line">  <span class="comment">// virtual  ~Shape()&#123;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Circle* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Circle* <span class="title">Circle::clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Circle</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Can we make a class constructor <em>virtual</em> in C++ to create polymorphic objects?</strong> </p>
<p>No. C++ being statically typed (the purpose of RTTI is different) language, it is meaningless to the C++ compiler to create an object polymorphically. The compiler must be aware of the class type to create the object. </p>
<p>In C++, the constructor cannot be virtual, because when a constructor of a class is executed there is no virtual table in the memory, means no virtual pointer defined yet.</p>
<h2 id="Virtual-function-table"><a href="#Virtual-function-table" class="headerlink" title="Virtual function table"></a>Virtual function table</h2><p><img src="https://www.learncpp.com/images/CppTutorial/Section12/VTable.gif" alt="img"></p>
<p>First, every class that uses virtual functions (or is derived from a class that uses virtual functions) is given its own virtual table. This table is simply a static array of function pointers that the compiler sets up at compile time. Each entry points to the most-derived function accessible by that class.</p>
<p>Second, the compiler also adds a hidden pointer to the base class, which we will call *____vptr. *____vptr is set (automatically) when a class instance is created so that it points to the virtual table for that class. Unlike the *this pointer, which is actually a function parameter used by the compiler to resolve self-references, *____vptr is a real pointer. Consequently, it makes each class object allocated bigger by the size of one pointer. It also means that *____vptr is inherited by derived classes, which is important.</p>
<h3 id="Polymorphism-in-C"><a href="#Polymorphism-in-C" class="headerlink" title="Polymorphism in C++"></a>Polymorphism in C++</h3><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20200703160531/Polymorphism-in-CPP.png" alt="Polymorphism-in-CPP"></p>
<ul>
<li><p>Function Overloading.</p>
</li>
<li><p>Operator overloading</p>
</li>
<li><p>Runtime Polymorphism: Function overriding.</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base *bptr;</span><br><span class="line">    derived d;</span><br><span class="line">    bptr = &amp;d;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//virtual function, binded at runtime (Runtime polymorphism)</span></span><br><span class="line">    bptr-&gt;<span class="built_in">print</span>(); <span class="comment">// print derived class</span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">// Non-virtual function, binded at compile time</span></span><br><span class="line">    bptr-&gt;<span class="built_in">show</span>(); <span class="comment">// show base class</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="Const-in-C"><a href="#Const-in-C" class="headerlink" title="Const in C++"></a>Const in C++</h2><h5 id="Const-member-functions"><a href="#Const-member-functions" class="headerlink" title="Const member functions"></a>Const member functions</h5><p>The idea of const functions is not to allow them to modify the object on which they are called.</p>
<h5 id="Const-Classes"><a href="#Const-Classes" class="headerlink" title="Const Classes"></a>Const Classes</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A anInstance = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>Can only call const functions.</p>
<h5 id="Const-variables"><a href="#Const-variables" class="headerlink" title="Const variables"></a>Const variables</h5><p>Must be initialized using Initializer List.</p>
<h2 id="Static-in-C"><a href="#Static-in-C" class="headerlink" title="Static in C++"></a>Static in C++</h2><h5 id="Static-variables-in-a-Function"><a href="#Static-variables-in-a-Function" class="headerlink" title="Static variables in a Function:"></a><strong>Static variables in a Function</strong>:</h5><p>When a variable is declared as static, space for <strong>it gets allocated for the lifetime of the program</strong>. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// static variable</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)    </span><br><span class="line">        <span class="built_in">demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Static-variables-in-a-class"><a href="#Static-variables-in-a-class" class="headerlink" title="Static variables in a class"></a><strong>Static variables in a class</strong></h5><p>As the variables declared as static are initialized only once as they are allocated space in separate static storage so, the static variables <strong>in a class are shared by the objects.</strong> </p>
<h5 id="Class-objects-as-static"><a href="#Class-objects-as-static" class="headerlink" title="Class objects as static"></a><strong>Class objects as static</strong></h5><p>Just like variables, objects also when declared as static have a scope till the lifetime of program.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> GfG obj;</span><br></pre></td></tr></table></figure>

<h5 id="Static-functions-in-a-class"><a href="#Static-functions-in-a-class" class="headerlink" title="Static functions in a class"></a><strong>Static functions in a class</strong></h5><p><strong>Static member functions are allowed to access only the static data members or other static member functions</strong>, they can not access the non-static data members or member functions of the class.</p>
<h2 id="RTTI-Run-Time-Type-Information"><a href="#RTTI-Run-Time-Type-Information" class="headerlink" title="RTTI (Run-Time Type Information)"></a>RTTI (Run-Time Type Information)</h2><p>There are three main C++ language elements to run-time type information:</p>
<ul>
<li><p>The <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/dynamic-cast-operator?view=msvc-160">dynamic_cast</a> operator.</p>
<ul>
<li><p>Used for conversion of polymorphic types.</p>
</li>
<li><p>RTTI is available only for classes that are <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">polymorphic</a>, which means they have at least one <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtual_method">virtual method</a>. (All have virtual destructor)</p>
</li>
</ul>
</li>
<li><p>The <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/typeid-operator?view=msvc-160">typeid</a> operator.</p>
<ul>
<li>Used for identifying the exact type of an object.</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(person).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// Person (statically known at compile-time).</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>The <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/type-info-class?view=msvc-160">type_info</a> class.</p>
<ul>
<li>Used to hold the type information returned by the <strong><code>typeid</code></strong> operator.</li>
</ul>
</li>
</ul>
<h2 id="Pure-virtual-functions-and-virtual-functions"><a href="#Pure-virtual-functions-and-virtual-functions" class="headerlink" title="Pure virtual functions and virtual functions"></a>Pure virtual functions and virtual functions</h2><ul>
<li>A virtual function makes its class a <em>polymorphic base class</em>.<ul>
<li>Virtual functions called through base class pointers/references will be resolved at run-time. </li>
</ul>
</li>
<li>A pure virtual function implicitly makes the class it is defined for <em>abstract</em><ul>
<li> Abstract classes cannot be instantiated. Derived classes need to override/implement all inherited pure virtual functions. </li>
</ul>
</li>
</ul>
<h2 id="Protected"><a href="#Protected" class="headerlink" title="Protected"></a>Protected</h2><p>Class member declared as Protected are inaccessible outside the class but they can be accessed by any subclass(derived class) of that class.</p>
<h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><h3 id="Example-of-Blocking-Queue"><a href="#Example-of-Blocking-Queue" class="headerlink" title="Example of Blocking Queue"></a>Example of Blocking Queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BLOCKINGQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCKINGQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlockingQueue</span>():<span class="built_in">lk</span>(), <span class="built_in">sig</span>(), <span class="built_in">q</span>()&#123;&#125;</span><br><span class="line">    <span class="comment">// don&#x27;t allow copy ctor</span></span><br><span class="line">    <span class="built_in">BlockingQueue</span>(<span class="keyword">const</span> BlockingQueue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    BlockingQueue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> BlockingQueue&amp; b) = <span class="keyword">delete</span>; </span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BlockingQueue</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow rvalue reference</span></span><br><span class="line">  	<span class="comment">// move constructor and move assignment</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      	<span class="comment">// unique_lock not lk.lock()</span></span><br><span class="line">      	<span class="comment">// could also use lock_guard if no need for condition_variable: std::lock_guard&lt;std::mutex&gt; guard(myMutex);</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lkguard</span><span class="params">(lk)</span></span>; <span class="comment">// can use lkguard.unlock() if want to release early</span></span><br><span class="line">        q.<span class="built_in">push</span>(value);</span><br><span class="line">        sig.<span class="built_in">notify_all</span>();</span><br><span class="line">      	<span class="comment">// end of life-cycle for lkguard, releases.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(lk)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(value);</span><br><span class="line">        sig.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">  	<span class="comment">// wait until queue not empty</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(lk)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>())</span><br><span class="line">            sig.<span class="built_in">wait</span>(lock);</span><br><span class="line">        <span class="function">T <span class="title">value</span><span class="params">(std::move(q.front()))</span></span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(lk)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; q;</span><br><span class="line">    std::mutex lk;</span><br><span class="line">    std::condition_variable sig;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>master 线程 （生产者）：负责往阻塞队列中塞入数据，并唤醒正在阻塞的 worker 线程。</li>
<li>worker 线程（消费者）：负责从阻塞队列中取数据，如果没有数据便阻塞，直到被 master 线程唤醒。</li>
</ul>
<h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span> <span class="comment">// shared_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span>  <span class="comment">// mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// version 2:</span></span><br><span class="line"><span class="comment">// with problems below fixed:</span></span><br><span class="line"><span class="comment">// 1. thread is safe now</span></span><br><span class="line"><span class="comment">// 2. memory doesn&#x27;t leak</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::shared_ptr&lt;Singleton&gt; <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance_ptr==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(m_instance_ptr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">              m_instance_ptr = std::shared_ptr&lt;Singleton&gt;(<span class="keyword">new</span> Singleton);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> std::shared_ptr&lt;Singleton&gt; m_instance_ptr;</span><br><span class="line">    <span class="keyword">static</span> std::mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialization static variables out of class</span></span><br><span class="line">Singleton::Ptr Singleton::m_instance_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">static</span> Singleton *instance;</span><br><span class="line">   <span class="keyword">int</span> data;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// Private constructor so that no objects can be created.</span></span><br><span class="line">   <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">      data = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">static</span> Singleton *<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance)</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span> -&gt; data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span> -&gt; data = data;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Initialize pointer to zero so that it can be initialized in first call to getInstance</span></span><br><span class="line">Singleton *Singleton::instance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Singleton *s = s-&gt;<span class="built_in">getInstance</span>();</span><br><span class="line">   cout &lt;&lt; s-&gt;<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">   s-&gt;<span class="built_in">setData</span>(<span class="number">100</span>);</span><br><span class="line">   cout &lt;&lt; s-&gt;<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="STL-sort"><a href="#STL-sort" class="headerlink" title="STL sort"></a>STL sort</h2><p>The algorithm used by sort() is <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/know-your-sorting-algorithm-set-2-introsort-cs-sorting-weapon/"><strong>IntroSort</strong></a>. Introsort being a hybrid sorting algorithm uses three sorting algorithm to minimize the running time, <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/quick-sort/">Quicksort</a>, <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/heap-sort/">Heapsort</a> and <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/insertion-sort/">Insertion Sort</a>. Simply putting, it is the best sorting algorithm around. It is a hybrid sorting algorithm, which means that it uses more than one sorting algorithms as a routine. </p>


  </article>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <div class="busuanzi center">
    page PV:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    site PV:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    site UV:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>


    





    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot">
    <div class="firstrow">
        <a href="#top" target="_self">
        <svg class="i-caret-right" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M10 30 L26 16 10 2 Z"></path>
        </svg>
        </a>
        
    </div>
    <div class="secondrow">
        <a target="_blank" rel="noopener" href="https://github.com/Abracax">
        Abracax
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/blog/js/search.min.js"></script>
<script type="text/javascript">

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

var path = "/blog/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

</body>
</html>
